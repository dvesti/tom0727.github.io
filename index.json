[{"categories":["算法"],"contents":"介绍 数论分块一般用于解决 $\\sum\\limits_{i}^{\\frac{N}{i}}$ 的求和问题。（即，含有 $\\lfloor \\frac{N}{i} \\rfloor$ 的求和式子）\n数论分块主要利用了 $\\lfloor \\frac{N}{i} \\rfloor$ 的取值范围相当有限的特点，所以有\n$$i \\leq j, ~\\lfloor \\frac{N}{i} \\rfloor = \\lfloor \\frac{N}{j} \\rfloor$$\n这样一些求和问题就可以转化为 $(j-i+1) \\times \\lfloor \\frac{N}{j} \\rfloor$ （或者类似的形式）\n时间复杂度：$O(\\sqrt n)$\n证明 $\\forall i \\leq n,$ $\\exists$ 最大的 $j$ 使得 $~i \\leq j \\leq n$，且 $\\lfloor \\frac{n}{i} \\rfloor = \\lfloor \\frac{n}{j} \\rfloor$\n则 $$j = \\lfloor \\frac{n}{\\lfloor \\frac{n}{i} \\rfloor} \\rfloor$$\n 证明：\n显然 $j \\leq n$，只要证 $j \\geq i$：\n因为 $j = \\lfloor \\frac{n}{\\lfloor \\frac{n}{i} \\rfloor} \\rfloor$，又因为 $i = \\lfloor \\frac{n}{\\frac{n}{i}} \\rfloor$ （分母没有下取整）\n因为 $\\lfloor \\frac{n}{i} \\rfloor \\leq \\frac{n}{i}$，所以有 $j \\geq i$\n例题 例1 求 $\\sum\\limits_{i=1}^N \\lfloor \\frac{N}{i} \\rfloor$  以下的代码中，我们令 l,r 代表上文的 i,j\n int r; for (int l = 1; l \u0026lt;= n; l = r + 1) { // 注意这里是 l = r+1 r = n / (n / i); ans += (n / l) * (r - l + 1); }  • 可以发现，数论分块的本质思想是 枚举 $\\lfloor \\frac{N}{i} \\rfloor$ 的值。\n例2 洛谷P2261 余数求和 题意\n给定正整数 $n,k \\leq 10^9$，求 $\\sum\\limits_{i=1}^n k \\text{ mod } i$\n 题解 因为 （以下略去 下取整符号） $$k \\text{ mod } i = k - \\frac{k}{i} \\times i$$\n对于 $n \u0026gt; k$ 的部分，就加上 $(n-k) \\times k$。\n对于 $n \\leq k$ 的部分，有 $$\\sum\\limits_{i=1}^n k \\text{ mod } i = n\\times k - \\sum\\limits_{i=1}^n \\frac{k}{i} \\times i$$\n然后数论分块枚举 $\\lfloor \\frac{k}{i} \\rfloor$ 的值，每个值分别用等差数列求和即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll n,k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; ll ans = 0; if (n \u0026gt; k) { ans += (n-k) * k; n = k; } ll r; ans += (n*k); for (ll l = 1; l \u0026lt;= n; l = r+1) { r = min(n, k / (k/l)); // 注意这里取 min，因为 k/(k/l) 有可能超过n ans -= (k/l) * ((l+r) * (r-l+1) / 2LL); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 Atcoder ABC132F Small Products 题意\n给定正整数 $n \\leq 10^9$，$2 \\leq k \\leq 100$，求满足以下条件的序列数量：\n 长度为 $k$ 任意两个相邻元素的乘积 $\\leq n$  答案对 $10^9+7$ 取模。\n 题解 很容易发现 dp 思路：\n设 $dp[i][j]$ 为：当前用到第 $i$ 个元素，结尾的元素的值为 $j$ 的数量。则答案为 $\\sum\\limits_{j=1}^{n}dp[k][j]$\n但是 $n \\leq 10^9$，dp数组开不了这么大。\n我们可以考虑只将 dp[][] 的第二维开到 $\\sqrt n$ 的大小，对于 $j \u0026gt; \\sqrt n$ 的部分用数论分块解决。\n令 $m = \\sqrt n$，且维护前缀和 $sum[i][j] = \\sum\\limits_{k=1}^j dp[i][j]$，转移方程有：\n$$dp[i][1] = \\sum\\limits_{j=1}^n dp[i-1][j] = \\sum\\limits_{j=1}^m dp[i-1][j] + \\sum\\limits_{j=m+1}^n dp[i-1][j]$$\n其中，\n$$\\forall j \u0026gt; m, ~dp[i-1][j] = \\sum\\limits_{k=1}^{\\lfloor \\frac{n}{j} \\rfloor} dp[i-2][k]$$\n会发现，对于不同的 $j$，$\\lfloor \\frac{n}{j} \\rfloor$ 的取值相当有限，所以可以用数论分块。所以有：\n$$dp[i][1] = sum[i-1][j] + \\sum\\limits_{j=m+1}^n \\sum\\limits_{k=1}^{\\lfloor \\frac{n}{j} \\rfloor} dp[i-2][k] = sum[i-1][j] + \\sum\\limits_{j=m+1}^n sum[i-2][\\frac{n}{j}]$$\n第二项用数论分块处理即可，注意到随着 $j$ 的增大，$\\frac{n}{j}$ 逐渐减小，所以可以反着枚举 $j$ （即 $j = m~\u0026hellip;~1$）\n最后，答案就是 $dp[k+1][1] = \\sum\\limits_{j=1}^{n}dp[k][j]$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll n,k,m; ll dp[103][31642]; ll sum[103][31642]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; m = sqrt(n); for (int i = 1; i \u0026lt;= m; i++) dp[1][i] = 1, sum[1][i] = sum[1][i-1] + 1; for (int i = 1; i \u0026lt;= m; i++) dp[2][i] = n/i, sum[2][i] = (sum[2][i-1] + dp[2][i]) % mod; for (int i = 3; i \u0026lt;= k+1; i++) { ll cur = 0; ll l = m+1,r; for (int j = m; j \u0026gt;= 1; j--) { //倒序枚举 j dp[i][j] = sum[i-1][m]; if (n/j \u0026lt;= m) { // 注意这里需要特判，否则 n/j \u0026lt;= m 是有可能的，导致RE continue; } r = min(n/j, n / (n/l)); cur = (cur + ((r-l+1) * (sum[i-2][n/l]) % mod)) % mod; l = r + 1; dp[i][j] = (dp[i][j] + cur) % mod; } for (int j = 1; j \u0026lt;= m; j++) sum[i][j] = (sum[i][j-1] + dp[i][j]) % mod; } ll ans = dp[k+1][1]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  ","date":"2021-03-10T15:49:46+08:00","permalink":"https://tom0727.github.io/post/027-%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/","tags":["数学"],"title":"数论分块"},{"categories":["题解"],"contents":"题目链接 题意\n给定 $k$ 个 box，每个 box $i$ 里有 $n_i$ 个整数，所有整数均不同。\n现在我们需要执行 Exactly Once 以下操作：\n从每一个box中拿一个数出来，然后以permutation的形式放回每一个box（即每一个box放入且仅放入一个数）。\n判断是否存在这样的操作使得所有box里的sum相同，如果有，输出具体方案。\n其中，$k \\leq 15, n \\leq 5000$\n 题解 首先，所有box的sum必须被 $k$ 整除，否则无解。\n令 $tar$ 为最终每个box的sum。\n我们可以枚举 $box ~1$ 要拿哪个数出来（叫做 $a_1$），这样我们就可以知道它需要被放入哪个数（叫做 $b_1$）。又因为所有数字都不相同，故我们就可以知道 $b_1$ 的来源是哪个box，假设来自 $box_i$，那么我们就可以得到 $a_i = b_1$，于是就可以计算出 $b_i$，一直这么继续下去，如果最终形成了一个完整的环（以 $box_1$ 作为起点，并且以 $box_2$ 作为终点）的话，就说明这个方案可行。\n但是，这个环不一定覆盖了所有的点。所以我们需要找到所有的环，我们分别以 $1,2,3,\u0026hellip;,k$ 作为起点，并且对于每个box都枚举一下要拿的数。这样我们可以最多形成 $\\sum\\limits_{i=1}^k n_i \\leq 75000$ 个环。并且每个环一定互不相同。\n 现在的问题就转化为：给定了这些环，我们能否从中挑选出几个环，使得每个 $box$ 被访问，且仅被访问一次？\n用 Bitmask ！\n因为 $k \\leq 15$，我们将每个环表示为一个bitmask，比如某个环是 $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 1$，那么对应的bitmask就是 $000\u0026hellip;1011$。\n我们会发现，可能会有很多个环对应同一个bitmask，但是没关系，我们只需要输出一个解即可。\n 最后，问题转化为：给定一些bitmask，如何让它们组合成 $2^k-1$，且每个bit仅被覆盖一次？\n用 状压dp！\n定义 bool ori[(1\u0026lt;\u0026lt;16)+2], dp[(1\u0026lt;\u0026lt;16)+2];\n其中 ori[mask] 代表这个mask是否由 单独一个环 所组成，而 dp[mask] 代表这个mask能否由 $1$ 个 或多个环 组成。\n然后就是一个很经典的模版了：\nfor (int mask = 0; mask \u0026lt;= (1\u0026lt;\u0026lt;k)-1; mask++) { if (ori[mask]) { dp[mask] = 1; continue; } for (int sub = mask; sub; sub = (sub-1) \u0026amp; mask) { // 枚举mask的子集，使用 (sub-1) \u0026amp; mask来加速枚举 if (dp[sub] \u0026amp;\u0026amp; dp[mask ^ sub]) { // 使用xor保证同一个bit只被覆盖一次 dp[mask] = 1; break; } } }   最后就是实现了，本题实现起来相当麻烦，找 完整环 我用的是 $dfs$ + $bitmask$ + 记录起点（和起点使用的数），每次找到一个环，就把 起点 放在对应的 $bitmask$ 数组 plan[] 里。\n在找完所有的环之后，再根据每个 $bitmask$，再进行一次 $dfs$ 来找到这个环的具体路径。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define pii pair\u0026lt;int,int\u0026gt; int k; int adj[16][5002]; //记录第i个box的第j个数 int sz[16]; //记录第i个box的大小 ll sum[16]; ll diff[16]; // 记录第i个box的sum和target的差 unordered_map\u0026lt;ll, int\u0026gt; belong; // 记录某个数属于第几个box pii plan[(1\u0026lt;\u0026lt;16)+2]; // 储存每个bitmask对应的起点 {start, a} bool ori[(1\u0026lt;\u0026lt;16)+2]; bool dp[(1\u0026lt;\u0026lt;16)+2]; int from[(1\u0026lt;\u0026lt;16)+2]; // 记录每个bitmask在dp过程中由哪个子集转移过来的 pii ans[16]; void dfs(int cur, ll a, int mask, int start, ll oa) { //cur: current vertex, a: the number we are taking OUT from cur, start: the starting vertex, oa: the \u0026quot;a\u0026quot; for starting vertex ll need = a - diff[cur]; if (!belong.count(need)) return; // no vertex to go int to = belong[need]; mask |= (1\u0026lt;\u0026lt;(cur-1)); if (to == start \u0026amp;\u0026amp; need == oa) { ori[mask] = 1; plan[mask] = {start, oa}; return; } if (mask \u0026amp; (1\u0026lt;\u0026lt;(to-1))) return; // form a cycle, but not a cycle start with \u0026quot;start\u0026quot; dfs(to, need, mask, start, oa); } void dfs2(int cur, ll a, int mask, int start) { ll need = a - diff[cur]; int to = belong[need]; mask |= (1\u0026lt;\u0026lt;(cur-1)); ans[to] = {need, cur}; if (to == start) { return; } dfs2(to, need, mask, start); } void findans(int mask) { if (!ori[mask]) { findans(from[mask]); findans(from[mask] ^ mask); return; } int start = plan[mask].first; ll a = plan[mask].second; dfs2(start, a, 0, start); } int main() { cin \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) { int n; cin \u0026gt;\u0026gt; n; sz[i] = n; for (int j = 1; j \u0026lt;= n; j++) { ll a; cin \u0026gt;\u0026gt; a; adj[i][j] = a; sum[i] += a; belong[a] = i; } } ll tar = 0; for (int i = 1; i \u0026lt;= k; i++) tar += sum[i]; if (tar % k) { cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; endl; return 0; } tar = tar/k; for (int i = 1; i \u0026lt;= k; i++) { diff[i] = sum[i] - tar; } for (int start = 1; start \u0026lt;= k; start++) { for (int j = 1; j \u0026lt;= sz[start]; j++) { dfs(start, (ll)adj[start][j], 0, start, adj[start][j]); } } for (int mask = 0; mask \u0026lt;= (1\u0026lt;\u0026lt;k)-1; mask++) { if (ori[mask]) { dp[mask] = 1; continue; } for (int sub = mask; sub; sub = (sub-1) \u0026amp; mask) { if (dp[sub] \u0026amp;\u0026amp; dp[mask ^ sub]) { dp[mask] = 1; from[mask] = sub; break; } } } if (dp[(1\u0026lt;\u0026lt;k)-1]) { cout \u0026lt;\u0026lt; \u0026quot;Yes\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; findans((1\u0026lt;\u0026lt;k)-1); for (int i = 1; i \u0026lt;= k; i++) printf(\u0026quot;%d %d\\n\u0026quot;, ans[i].first, ans[i].second); } else { cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2021-03-09T12:34:01+08:00","permalink":"https://tom0727.github.io/post/026-cf-1243e/","tags":["图论","dp"],"title":"CF1243E 题解（图论，状压dp）"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1154/problem/G\n题意\n给定 $n$ 个正整数 $a_1,a_2,\u0026hellip;,a_n$，求 $i \\neq j$ 使得 $\\text{lcm}(a_i, a_j)$ 最小？\n其中 $2 \\leq n \\leq 10^6, 1 \\leq a_i \\leq 10^7$\n 题解 一般和 $gcd, lcm$ 相关的题，一般就 $2$ 种trick：\n 质因子分解 枚举 $gcd$ 的值  这道题是 枚举 $gcd$ 的值。因为 $lcm(a_i,a_j) = \\frac{a_ia_j}{\\gcd(a_i,a_j)}$，所以我们枚举一下 $gcd(a_i,a_j)$ 的值即可。\n设 $g$ 为可能的 $gcd$ 的值，从 $1$ 枚举到 $10^7$，对于每一个 $g$，只要找出 最小的两个 $a_i,a_j$ 使得 $g|a_i, g|a_j$ 即可。\n时间复杂度：$T(n) = \\frac{10^7}{1} + \\frac{10^7}{2} + \u0026hellip; + \\frac{10^7}{10^7} = 10^7(1+\\frac{1}{2} + \u0026hellip; \\frac{1}{10^7}) = O(10^7 \\log(10^7))$\n 证明正确性：\n无论最终答案是什么，$\\gcd(a_i,a_j)$ 必然会被枚举到。所以不会漏解。\n如果我们枚举到的 $g$ 不一定是真的 $gcd$ 呢？比如 $g = 2$，然后 $a_i$ 中最小的两个倍数为 $4, 8$？\n答：我们总会枚举到真正的 $gcd$，如果 $g$ 不是真实的 $gcd$，它只会比真实的 $gcd$ 更小，所以获得的 $lcm$ 更大，所以不影响答案的正确性。\n  另：枚举 $gcd$ 的trick之前在 Atcoder-ABC-162E 也出现过。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e6+5; const int maxm = 1e7+5; int arr[maxn]; int vis[maxm]; // 不要用 unordered_set, 会TLE int n; ll ans = 1e18; int ai,aj; int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]); if (vis[arr[i]] \u0026amp;\u0026amp; arr[i] \u0026lt; ans) ans = arr[i], ai = vis[arr[i]], aj = i; vis[arr[i]] = i; } for (int g = 1; g \u0026lt;= 1e7; g++) { int cur = 0; if ((g\u0026lt;\u0026lt;1) \u0026gt; ans) break; // 优化时间 for (int j = g; j \u0026lt;= 1e7; j += g) { if (vis[j]) { if (cur) { int d = j / g; ll r = 1LL * cur * d; if (r \u0026lt; ans) { ai = vis[cur]; aj = vis[j]; ans = r; } break; } else cur = j; } } } if (ai \u0026gt; aj) swap(ai, aj); printf(\u0026quot;%d %d\\n\u0026quot;, ai,aj); }  ","date":"2021-03-08T21:36:22+08:00","permalink":"https://tom0727.github.io/post/025-cf-1154g/","tags":["枚举","数论"],"title":"CF1154G 题解（gcd/lcm的枚举优化）"},{"categories":["算法"],"contents":"介绍 莫队算法是一种基于分块思想的暴力算法，一般应用于同时满足以下条件的区间问题中：\n 已知 $[L,R]$ 之间的答案，能在 $O(1)$ 时间内转移到 $[L+1,R], [L-1,R], [L,R+1], [L,R-1]$ 的答案。 所有询问均离线。 不存在修改。  我们用模版举个例子：\n题意\n给定一个长度为 $N$ 的正整数序列 $a$，给定一个 $k$，满足 $\\forall i, a_i \\in [1,k]$。\n现在有 $M$ 个询问，每个询问给定一个区间 $[l,r]$，求 $\\sum_{i=1}^kc_i^2$\n其中 $c_i$ 为数字 $i$ 在 $[l,r]$ 中的出现次数。\n数据范围：$1 \\leq n,m,k \\leq 5\\times10^4$\n 算法 Part1 O(1)的状态转移 对于上面的例题，我们可以发现从 $[L,R]$ 转移到 $[L,R+1]$ 是 $O(1)$ 的。\n我们维护两个指针 $l,r$，并且维护一个 cnt[] 数组来记录当前区间的 $c_i$，在 $r$ 右移一格的时候，加上对应的 $cnt$，然后要维护的 $\\sum_{i=1}^kc_i^2$ 也很好转移，计算一下，就会得到\n$s_{l,r+1} = s_{l,r} + 2\\times c_{a_{r+1}} + 1$\n同理对于其他三种情况，转移都是 $O(1)$ 的。\n所以，假设我们有两个询问 $[L_1, R_1], [L_2, R_2]$，我们在询问完 $[L_1, R_1]$ 后，将左右指针一个个移动到 $[L_2, R_2]$ 似乎就可以节省一点时间了。（如果它们离得比较近的话）\nPart2 莫队思路 既然我们可以通过维护两个指针 $l,r$ 来快速转移，我们又事先知道所有的询问（因为询问离线），那有什么办法将这些询问靠近一些，来节省更多时间呢？\n分块思想！\n我们将区间划分为 $\\sqrt n$ 块，然后对于每个询问 $[L_i,R_i]$，我们根据 $L_i$ 的值，把它放进对应的块中。\n然后，我们将所有的询问首先根据 所在块的编号 来sort，对于同一块内的询问，根据 $R_i$ 从小到大 来sort。\n最后，根据sort的顺序来处理每个询问，询问之间的转移 就按照上面的左右指针移动来处理。这样我们能在 $O(n\\sqrt n)$ 时间内处理好每一个区间。\n算法步骤  预处理所有询问，记录询问的 l,r，记录 be （代表 l 对应是哪个块），记录 id（代表原先是第几个询问）。 根据 be 作为第一关键字，r 作为第二关键字进行sort。 定义global variable int l = 1, r = 0, ans = 0。 按照sort后的顺序进行询问，调整 l,r 指针，并相应更新 ans，然后将 ans 根据 id 放入答案数组中。  需要注意的点  注意在转移过程中，使用的是 --l 还是 l++。r 还有更新 ans 的时候也类似，要根据具体情况来看。 注意初始情况下， l = 1, r = 0。 be 是根据 l 的位置决定的。  复杂度证明 先注意：\n 同一个块内的 $L_i$ 并没有顺序。 同一个块内的 $R_i$ 没有限制，可以横跨整个区间。  左指针在块内移动 的复杂度：注意到，同一个块内的 $L_i$ 并没有顺序，所以每次询问可能有 $O(B)$ 的复杂度（$B$为块的大小）。总复杂度为 $O(mB)$\n右指针在块内移动 的复杂度：因为是 $R_i$ 是有序的，所以在同一个块内移动的总复杂度为 $O(n)$\n左指针在块之间移动 的复杂度：每次移动复杂度为 $O(2B)$。总复杂度为 $O(\\frac{n}{B} * 2B) = O(2n)$\n右指针在块之间移动 的复杂度：总共有 $\\frac{n}{B}$ 个块，每次在块之间移动没有限制，复杂度为 $O(n)$。总复杂度为 $O(\\frac{n^2}{B})$\n综上，复杂度为 $O(mB) + O(n) + O(\\frac{n^2}{B})$\n当我们取 $B = \\sqrt n$ 时，复杂度为 $O(n \\sqrt n)$\n• 实际上最优复杂度应该取 $B = \\frac{n}{\\sqrt m}$，总复杂度为 $O(n \\sqrt m)$\n例题 例1 小B的询问 就是上面的例题，这里直接放代码。\n代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 5e4+5; const int maxm = 5e4+5; int n,m,k; int sz; int arr[maxn]; ll cnt[maxn]; ll ans[maxn]; struct query { int l,r,be,id; } q[maxm]; bool cmp(query\u0026amp; a, query\u0026amp; b) { if (a.be == b.be) return a.r \u0026lt; b.r; return a.be \u0026lt; b.be; } int l = 1,r = 0; ll add(int x) { ll res = 2LL * cnt[arr[x]] + 1LL; cnt[arr[x]]++; return res; } ll del(int x) { ll res = -2LL * cnt[arr[x]] + 1LL; cnt[arr[x]]--; return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; sz = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].id = i; q[i].be = (q[i].l-1) / sz; } sort(q+1, q+m+1, cmp); ll res = 0; for (int i = 1; i \u0026lt;= m; i++) { int ql = q[i].l, qr = q[i].r; while (r \u0026lt; qr) res += add(++r); while (r \u0026gt; qr) res += del(r--); while (l \u0026lt; ql) res += del(l++); while (l \u0026gt; ql) res += add(--l); ans[q[i].id] = res; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例2 小Z的袜子 题意\n有 $N$ 个袜子，每个袜子 $i$ 有一个颜色 $c_i$，给定 $M$ 个询问 $[L,R]$，每次询问回答 $[L,R]$ 区间内随机抽两个袜子，颜色相同的概率？\n其中 $N,M \\leq 50000, c_i \\in [1,N]$\n 题解 维护 分子和分母：\n每次区间长度加 $1$：分母增加 $len$（$len$ 为增加前的区间长度），分子增加 $cnt_{c_i}$ （$cnt_{c_i}$ 为新增的颜色 $c_i$ 原来的数量）。\n每次区间长度减 $1$：分母减少 $len-1$（$len$ 为减少前的区间长度），分子减少 $cnt_{c_i} - 1$ （$cnt_{c_i}$ 为减少的颜色 $c_i$ 原来的数量）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const int maxn = 5e4+5; const int maxm = 5e4+5; int n,m; struct query { int l,r,be,id; ll nu,de; } q[maxm]; int arr[maxn]; int cnt[maxn]; bool cmp(query\u0026amp; a, query\u0026amp; b) { if (a.be == b.be) { return a.r \u0026lt; b.r; } return a.be \u0026lt; b.be; } ll nu = 0, de = 0; ll gcd(ll a, ll b) { if (!b) return a; return gcd(b, a%b); } int sz; int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); sz = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]); for (int i = 1; i \u0026lt;= m; i++) { int l,r; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;l,\u0026amp;r); q[i].id = i; q[i].be = (l-1)/sz; q[i].l = l, q[i].r = r; } sort(q+1, q+m+1, cmp); ll l = 1, r = 0; for (int i = 1; i \u0026lt;= m; i++) { int ql = q[i].l, qr = q[i].r, id = q[i].id; if (ql == qr) { q[id].nu = 0, q[id].de = 1; continue; } while (r \u0026lt; qr) de += (r-l+1), r++, nu += cnt[arr[r]], cnt[arr[r]]++; while (r \u0026gt; qr) de -= (r-l), nu -= (cnt[arr[r]] - 1), cnt[arr[r]]--, r--; while (l \u0026gt; ql) de += (r-l+1), l--, nu += cnt[arr[l]], cnt[arr[l]]++; while (l \u0026lt; ql) de -= (r-l), nu -= (cnt[arr[l]] - 1), cnt[arr[l]]--, l++; q[id].nu = nu, q[id].de = de; } for (int i = 1; i \u0026lt;= m; i++) { nu = q[i].nu, de = q[i].de; if (nu == 0) { printf(\u0026quot;0/1\\n\u0026quot;); continue; } ll g = gcd(nu,de); nu /= g, de /= g; printf(\u0026quot;%lld/%lld\\n\u0026quot;,nu,de); } }   例3 CF617E 题意\n给定 $n$ 个整数 $a_1,a_2,\u0026hellip;,a_n$，还有一个整数 $k$ ，以及 $m$ 个询问 $[l,r]$，每次询问求 有多少个$i,j$ 满足：\n $l \\leq i \\leq j \\leq r$ $a_i \\text{ xor } a_{i+1} \\text{ xor } \u0026hellip; \\text{ xor } a_j = k$  其中，$1 \\leq n,m \\leq 10^5, 0 \\leq k \\leq 10^6, 0 \\leq a_i \\leq 10^6$\n 题解 首先定义一个前缀 $\\text{ xor }$ 数组满足 $s_i = a_1 \\text{ xor } a_2 \\text{ xor } \u0026hellip; \\text{ xor } a_i$，这样问题转化为：\n每次询问求 有多少个$i,j$ 满足：\n $l \\leq i \\leq j \\leq r$ $s_i \\text{ xor } s_j = k$  注意到，$s_j = s_i \\text{ xor } k$，所以我们可以维护一个 cnt[] 数组，记录一下当前区间每个元素出现了多少次。\n然后，比如在区间扩张的过程中，就检查 cnt[] 中当前元素 cur 出现的次数，给 ans 加上，然后 cnt[cur ^ k]++;\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e5+5; const int maxm = 1e6+5; int n,m,k; struct query { int l,r,id,be; } q[maxn]; bool cmp(query a, query b) { if (a.be == b.be) return a.r \u0026lt; b.r; return a.be \u0026lt; b.be; } int l = 0, r = -1; int cnt[2*maxm]; int s[maxn]; ll b[maxn]; double start; ll ans = 0; void add(int x) { ans += (ll)cnt[s[x]]; cnt[s[x] ^ k]++; } void del(int x) { cnt[s[x] ^ k]--; ans -= (ll)cnt[s[x]]; } void ask(int L, int R) { while (r \u0026lt; R) add(++r); while (r \u0026gt; R) del(r--); while (l \u0026lt; L) del(l++); while (l \u0026gt; L) add(--l); } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; s[i]; for (int i = 1; i \u0026lt;= n; i++) s[i] ^= s[i-1]; int sz = sqrt(n); for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].l--; q[i].id = i; q[i].be = (q[i].l-1)/sz; } sort(q+1, q+m+1, cmp); for (int i = 1; i \u0026lt;= m; i++) { ask(q[i].l, q[i].r); b[q[i].id] = ans; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; b[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   带修莫队 略。例题参考：https://www.luogu.com.cn/problem/P1903\n参考链接  https://ouuan.github.io/post/%E8%8E%AB%E9%98%9F%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3/#%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F https://www.cnblogs.com/WAMonster/p/10118934.html  ","date":"2021-03-07T21:50:41+08:00","permalink":"https://tom0727.github.io/post/024-%E8%8E%AB%E9%98%9F/","tags":["莫队"],"title":"莫队"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc194/tasks/abc194_f\n题意\n给定一个数 $1\\leq N \\leq 16^{2\\times10^5}$，求：\n在 16进制 下，满足以下条件的整数 $x$ 数量：\n 拥有 Exactly $K$ 个不同的digit （例如 $x = 1F21$，就有3个不同的digit） $x \\in [1,N]$   题解 我们使用 dp，为了方便处理 $x \\leq N$ 的问题，我们从最高位（Most significant digit）开始处理。\n我们设 dp[i][j] 为，我们处理到了第 i 位，使用了 j 个不同的digit，且满足以下条件的数字 $x$ 的数量：\n $x$ 严格小于 $N$ 的前 i 位 $x \\neq 0$   注意，$x$ 不一定完全有 i 个digit，但是它至少有一个有效的digit。\n 由上，因为第一个条件，我们无论在这一位选择什么digit，都必然会仍然满足条件 $1$ 中的 严格小于 $N$。\n所以我们可以得到第一个转移方程：\nfor (ll j = 2; j \u0026lt;= k; j++) { dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (16-j+1)) % mod; dp[i][j] = (dp[i][j] + dp[i-1][j] * j) % mod; }   我们发现，这样只考虑到了前 i-1 位至少有一个有效digit的情况，没有考虑全部为前缀0的情况。\n如果前 i-1 位全是前缀0，那么无论在这一位选择任何数，都必然满足条件 $1$ 中的 严格小于 $N$。\n所以我们可以得到第二个转移方程：\ndp[i][1] = (dp[i-1][1] + 15) % mod;   注意到，我们的 dp 数组里，并没有包含 $x$ 的前 i-1 位 完全等同于 $N$ 的前 i-1 位的情况。我们需要单独处理它！\n我们在当前这一位（第i位），能够计入 dp 数组的只有 第 i 位小于 $N$ 的第 i 位的情况。\n并且，我们可以很容易得到 $N$ 的前 i-1 位有多少个不同的digit（这样就得到了 dp 数组里的 j）。\n所以，我们只要枚举一下，第 i 位可以选择的所有digit，计算一下不同的digit数量，然后计入 dp 数组即可。\n所以我们得到了第三个转移方程：\nmap\u0026lt;char, int\u0026gt; dict; // 用于将 0123456789ABCDEF map到对应的int set\u0026lt;int\u0026gt; used; // 记录N的前i-1位用了哪些数字 char c = s[i-1]; // N的第i位数字 int cur = dict[c]; int pre = used.size(); for (int j = 0; j \u0026lt; cur; j++) { //枚举所有可以选择的digit if (!used.count(j)) { // 计算不同digit的数量 dp[i][pre+1]++; } else dp[i][pre]++; } used.insert(cur);   最后别忘记，看一下 $N$ 自己是否也满足条件（拥有Exactly $K$ 个不同的digit）。\n 小结：\n本题是一个非常不错的dp，主要用了以下几个关键的trick：\n 对于 Exactly $K$ 不同的digit，我们不关心具体是哪几个digit，只需知道不同的digit数量就可以计数了。 通过限制 dp 数组的定义，让 dp 数组仅记录 严格小于 $N$ 的数字，方便计数。 单独处理 $x$ 与 $N$ 的前 i 位相同的情况，并且将符合条件的计数加到 dp 数组当中去。  需要重点关注的是这个 DP并不记录最终答案，而是记录 满足某种条件的部分答案，其余特殊情况单独处理的思想。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 2e5+5; ll dp[maxn][18]; string s; int k; map\u0026lt;char, int\u0026gt; dict; set\u0026lt;int\u0026gt; used; int main() { fastio; for (int i = 0; i \u0026lt;= 9; i++) dict[(char)(i+'0')] = i; int o = 10; for (char c = 'A'; c \u0026lt;= 'F'; c++) dict[c] = o++; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; int n = s.size(); dp[1][1] = dict[s[0]] - 1; used.insert(dict[s[0]]); for (ll i = 2; i \u0026lt;= n; i++) { char c = s[i-1]; dp[i][1] = (dp[i-1][1] + 15) % mod; int cur = dict[c]; for (ll j = 2; j \u0026lt;= k; j++) { dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (16-j+1)) % mod; dp[i][j] = (dp[i][j] + dp[i-1][j] * j) % mod; } int pre = used.size(); for (int j = 0; j \u0026lt; cur; j++) { if (!used.count(j)) { dp[i][pre+1]++; } else dp[i][pre]++; } used.insert(cur); } if (used.size() == k) dp[n][k]++; ll ans = dp[n][k] % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-03-06T22:16:46+08:00","permalink":"https://tom0727.github.io/post/023-at-abc194f/","tags":["计数","dp","进制"],"title":"Atcoder ABC 194F（计数dp，进制处理）"},{"categories":["算法"],"contents":"介绍 树链剖分主要用于将 树上修改/查询 通过 DFS序 变成 区间修改/查询，然后利用 线段树 进行修改/查询。\n我们可以用模版来举个例子：\n题意\n如题，已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：\n$1\\ x\\ y\\ z$ ：将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。\n$2\\ x\\ y$ ：求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。\n$3\\ x\\ z$ ：将以 $x$ 为根节点的子树内所有节点值都加上 $z$。\n$4\\ x$ ：求以 $x$ 为根节点的子树内所有节点值之和。\n 主要知识点有三个：DFS序，LCA，线段树\n前置知识回顾 DFS序 DFS序的作用是，根据DFS的顺序将节点编号，就可以得到以下性质：\n 同一个subtree内的编号是连续的，且parent的编号最小。 在从上到下的DFS过程中，一条链上的编号也是连续的，且越靠上，编号越小。   LCA（最近公共祖先） 在 LCA 中，寻找共同祖先的过程中，要注意不能往上跳过头了，在树链剖分中也一样，只不过没有采用倍增思想。\n 线段树 在树链剖分中，线段树的应用并没有什么变化。\n 概念定义   重儿子：每一个节点的child中，所在subtree（包括它自己）节点数最多的child 叫做该节点的重儿子（每个节点有且仅有一个重儿子）。\n  轻儿子：除了重儿子的所有节点，都是轻儿子。（我们可以把 root 看作一个轻儿子）\n  重边：一个节点连接它的重儿子的edge就是重边。\n  重链：以轻儿子作为起点，向下延伸，连接子树内的所有重儿子，形成的链叫做重链。\n（对于一个leaf，如果它是一个轻儿子，那么它自己形成一条重链）\n  算法 算法步骤如下：\n 进行第一次DFS dfs1() 进行第二次DFS dfs2() 建线段树 将树上操作 对应到 区间上，然后用线段树解决  第一次DFS 第一次DFS，我们需要维护的信息有：\n 记录每个点的 深度： dep[] 记录每个点的 parent： par[] 记录每个点的 subtree大小（包括它自己）：sz[] 记录每个点的 重儿子：son[]  int dep[maxn], par[maxn], sz[maxn], son[maxn]; void dfs1(int cur, int p) { dep[cur] = dep[p] + 1; par[cur] = p; sz[cur] = 1; // subtree包括自己 int maxsz = -1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, cur); sz[cur] += sz[to]; if (sz[to] \u0026gt; maxsz) { // 判断重儿子 maxsz = sz[to]; son[cur] = to; } } }  第二次DFS 第二次DFS，我们需要维护的信息有：\n 记录每个点的 DFS序编号：id[] 记录每个点 所在重链的最顶端：top[] （如果有），将树上的信息通过DFS序编号 转移到 区间上   注意：dfs2() 过程中，我们需要 优先处理重儿子，这是为了保证 同一条重链 对应的必然是 一段连续的区间。\n 这样处理以后，我们能得到如下的DFS序编号：\nint w[maxn]; //weight int arr[maxn]; // array for segment tree to use int top[maxn], id[maxn]; int cnt = 1; //current id void dfs2(int cur, int t) { id[cur] = cnt++; top[cur] = t; arr[id[cur]] = w[cur]; if (!son[cur]) return; // 这个节点是leaf dfs2(son[cur], t); // 优先处理重儿子 for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur] || to == son[cur]) continue; //重儿子处理过了 dfs2(to, to); // 轻儿子是重链的开始 } }  建线段树 常规操作，并没有什么不同。\n将树上操作对应到区间上 操作 $3,4$ （更新/查询一个子树内的值）：\n在DFS序中，同一个子树内的DFS序编号是连续的，我们有了 parent 对应的编号，就有了区间上的左端点，利用 sz[] 来找到 右端点，左右端点都有了，就用线段树处理即可。\nvoid update_tree(int u, ll x) { update(1, id[u], id[u]+sz[u]-1, x); } ll query_tree(int u) { return query(1, id[u], id[u]+sz[u]-1); }   操作 $1,2$ （更新/查询两个点之间最短路径的值）：\n给定两个点 u,v：\n  如果 u,v 在同一条重链上，那么对应的是区间上的一段连续区间（dep 较小的那个对应左端点，dep较深的那个对应右端点），直接用线段树即可。\n  否则，比较 top[u] 和 top[v]，如果 dep[top[u]] \u0026gt; dep[top[v]] （top[u] 比 top[v] 更深），就将 u 往上跳，在线段树上操作 u 到 top[u] 的这一段操作，然后跳到 par[top[u]] 上（即，重链顶端再往上一格），然后重新执行上述判断。\n   为什么要让 top 更深的来跳？为了保证不会跳过头！\n 证明：无论怎么跳，我们都不能超过 u,v 的LCA。设 LCA(u,v) = x，因为它们不在同一条链上，那么 u,v 必然在 x 的两边（或者，其中之一刚好等于 x，另外一个被一个轻儿子挡住了）。无论是哪种情况，因为重链有可能直接从 root 一直延伸下来，所以肯定不能选 top 更靠上层的那个。\n而选择 top 更深的那个，能够保证我们 最远只能刚好跳到x处（因为 x 有且仅有一个重儿子，如果不跳这个重儿子，必然不会跳出 x 的范围）。\n• 由上分析，我们还能发现：在往上跳的过程中，如果发现 u,v 在同一条重链上，那么 dep 较小的那个节点，就是 u,v 的LCA！\nvoid update_path(int u, int v, ll x) { while (top[u] != top[v]) { // u,v 还不是同一个重链上 if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); update(1, id[top[u]], id[u], x); u = par[top[u]]; // 往上跳 } if (dep[u] \u0026gt; dep[v]) swap(u,v); // dep较小的是左端点 update(1, id[u], id[v], x); } ll query_path(int u, int v) { ll res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); res = (res + query(1, id[top[u]], id[u])) % mod; u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); res = (res + query(1, id[u], id[v])) % mod; return res; }  时间复杂度 性质1 如果 $v$ 是 $u$ 的轻儿子，那么 $size(v) \\leq \\frac{size(u)}{2}$\n证明：根据定义即可。\n 性质2 树中任意两条节点之间，重链的数量 $\\leq \\log_2(n)$\n证明：因为每出现一个重链，意味着出现了一个轻儿子，根据性质1，size减少一半，所以\n#重链 $=$ #轻儿子 $= log_2(n)$\n 由性质1，2，我们可知：\n  路径修改/查询：每个重链进行一次线段树操作，有 $log_2(n)$ 个重链，每次线段树操作复杂度为 $log_2(n)$，所以每次路径操作的总复杂度为 $(log_2(n))^2$\n  子树修改/查询：只有一次线段树操作，所以复杂度为 $log_2(n)$\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e5+5; const int maxm = 2e5+10; struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int n,m,root,mod; int w[maxn]; //weight int dep[maxn], par[maxn], sz[maxn], son[maxn]; int top[maxn], id[maxn]; int arr[maxn]; // array for segment tree to use int cnt = 1; //current id void dfs1(int cur, int p) { dep[cur] = dep[p] + 1; par[cur] = p; sz[cur] = 1; // 包括自己 int maxsz = -1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, cur); sz[cur] += sz[to]; if (sz[to] \u0026gt; maxsz) { // 更新重儿子 maxsz = sz[to]; son[cur] = to; } } } void dfs2(int cur, int t) { id[cur] = cnt++; top[cur] = t; arr[id[cur]] = w[cur]; if (!son[cur]) return; // leaf dfs2(son[cur], t); for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur] || to == son[cur]) continue; dfs2(to, to); // 轻儿子是重链的开始 } } struct node { int l,r; ll sum = 0; ll lazy = 0; } tr[4*maxn]; inline ll len(int cur) { return tr[cur].r - tr[cur].l + 1; } void push_up(int cur) { tr[cur].sum = (tr[cur\u0026lt;\u0026lt;1].sum + tr[cur\u0026lt;\u0026lt;1|1].sum) % mod; } void push_down(int cur) { if (!tr[cur].lazy) return; int lc = cur\u0026lt;\u0026lt;1, rc = lc|1; tr[lc].lazy = (tr[lc].lazy + tr[cur].lazy) % mod; tr[rc].lazy = (tr[rc].lazy + tr[cur].lazy) % mod; tr[lc].sum = (tr[lc].sum + len(lc) * tr[cur].lazy) % mod; tr[rc].sum = (tr[rc].sum + len(rc) * tr[cur].lazy) % mod; tr[cur].lazy = 0; } void build(int cur, int L, int R) { tr[cur].l = L, tr[cur].r = R; if (L == R) { tr[cur].sum = arr[L]; return; } int mid = (L+R) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, L, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, R); push_up(cur); } void update(int cur, int L, int R, ll x) { int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy = (tr[cur].lazy + x) % mod; tr[cur].sum = (tr[cur].sum + x * len(cur)) % mod; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, L, R, x); push_up(cur); } ll query(int cur, int L, int R) { ll res = 0; int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].sum; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, L, R); push_up(cur); return res % mod; } void update_tree(int u, ll x) { update(1, id[u], id[u]+sz[u]-1, x); } ll query_tree(int u) { return query(1, id[u], id[u]+sz[u]-1); } void update_path(int u, int v, ll x) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); update(1, id[top[u]], id[u], x); u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); update(1, id[u], id[v], x); } ll query_path(int u, int v) { ll res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); res = (res + query(1, id[top[u]], id[u])) % mod; u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); res = (res + query(1, id[u], id[v])) % mod; return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; root \u0026gt;\u0026gt; mod; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); add(v,u); } dfs1(root, 0); dfs2(root, root); build(1, 1, n); while (m--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int u,v,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; x; update_path(u,v,x); } else if (op == 2) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; ll res = query_path(u,v); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else if (op == 3) { int u,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; x; update_tree(u, x); } else { int u; cin \u0026gt;\u0026gt; u; ll res = query_tree(u); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }  其他例题  https://codeforces.com/problemset/problem/343/D  参考链接  https://www.luogu.com.cn/problem/P3384 （模版题，上面的AC代码） https://www.cnblogs.com/chinhhh/p/7965433.html （强烈推荐） https://www.cnblogs.com/zwfymqz/p/8094500.html  ","date":"2021-03-06T15:58:27+08:00","permalink":"https://tom0727.github.io/post/022-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","tags":["树链剖分"],"title":"树链剖分"},{"categories":["算法"],"contents":"介绍 给定一棵有根树（不一定为binary tree），求两个节点的最近公共祖先？\n算法 LCA的思路和ST表比较相似，都是利用了倍增思想，大概流程如下：\n预处理：   用dfs预处理出每一个节点 $u$ 的第$1,2,4,8,\u0026hellip;,$ 个parent（即，如果从$u$ 开始，往上跳 $1,2,4,8,\u0026hellip;,$ 格，是哪个节点）\n  记录每一个节点的深度(depth)\n  预处理parent的时候，利用了倍增的思想：\nfor (int j = 1; j \u0026lt;= lg[d[cur]]; j++) par[cur][j] = par[par[cur][j-1]][j-1];   询问 $u,v$ 的LCA：   先比较 $u,v$ 的深度，将深的那个往上跳（使用倍增来跳），跳到同一深度。\n  比较一下当前 $u,v$ 是否相等，如果已经相等了就直接返回 $u$。\n  否则，尝试同时将 $u,v$ 往上跳，从 步幅最大 的开始尝试，如果发现 步幅过大（即 $u,v$ 的第 $j$ 个parent相同），就不跳（防止跳过头了），否则就两者同时往上跳。\n  最后，$u,v$ 必然不相同，此时再让它们同时往上跳 $1$ 格就是LCA了。\n  代码 Luogu-P3379-代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 5e5+5; const int maxm = 1e6+10; struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int par[maxn][33]; //记录parent int d[maxn]; //深度 int n,m,s; int lg[maxn]; //log2预处理 void dfs(int cur, int p) { par[cur][0] = p; d[cur] = d[p] + 1; for (int j = 1; j \u0026lt;= lg[d[cur]]; j++) par[cur][j] = par[par[cur][j-1]][j-1]; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, cur); } } int query(int u, int v) { if (d[u] \u0026lt; d[v]) swap(u,v); int diff = d[u] - d[v]; for (int j = 0; (1\u0026lt;\u0026lt;j) \u0026lt;= diff; j++) { if (diff \u0026amp; (1\u0026lt;\u0026lt;j)) { u = par[u][j]; } } if (u == v) return u; for (int j = lg[d[u]]; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) { // 不相同就往上跳 u = par[u][j], v = par[v][j]; } } return par[u][0]; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; // s是树的root for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); add(v,u); } lg[1] = 0, lg[2] = 1; for (int i = 3; i \u0026lt;= 5e5; i++) lg[i] = lg[i\u0026gt;\u0026gt;1] + 1; } int main() { init(); dfs(s, 0); while (m--) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; int a = query(u,v); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }  ","date":"2021-03-06T11:57:25+08:00","permalink":"https://tom0727.github.io/post/021-lca/","tags":["LCA","最近公共祖先"],"title":"最近公共祖先 LCA"},{"categories":["算法"],"contents":"介绍 三分法 (tenary search) 和 二分法(binary search) 类似，只不过三分法可以用于搜索一个 二次函数 的最值。\n以搜索二次函数最值为例，假如有一个二次函数存在最大值。\n要搜索这个最大值，可以令 $mid = \\frac{l+r}{2}$，然后令 $lmid = mid - eps$，$rmid = mid + eps$，然后比较一下 $f(lmid)$ 和 $f(rmid)$ 的大小。\n $f(lmid) \u0026lt; f(rmid)$：最大值一定在 $[lmid, r]$ 之间。 $f(lmid) \u0026gt; f(rmid)$：最大值一定在 $[l, rmid]$ 之间。   证明：假如 $f(lmid) \u0026lt; f(rmid)$，那么如果最大值在 $lmid$ 的左边则必然不可能，因为 $rmid$ 离最大值比 $lmid$ 更远。另外一种情况亦然。\n 例题 例1 洛谷P3382 题意\n给定一个 $N$ 次函数，保证 $[l,r]$ 内存在一个点 $x$，使得 $[l,x]$ 单调增，$[x,r]$ 单调减，求 $x$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = (double)1e-7; int n; double l,r; double arr[16]; double get(double x) { double res = 0; double cur = 1.0; for (int i = 1; i \u0026lt;= n+1; i++) { res += cur * arr[i]; cur *= x; } return res; } int main() { cin \u0026gt;\u0026gt; n; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; for (int i = n+1; i \u0026gt;= 1; i--) cin \u0026gt;\u0026gt; arr[i]; double low = l, high = r; while (high - low \u0026gt; 5e-7) { double mid = (low + high) * 0.5; double lmid = mid - eps, rmid = mid + eps; if (get(lmid) \u0026lt; get(rmid)) low = lmid; else high = rmid; } printf(\u0026quot;%.7f\\n\u0026quot;, low); }   例2 CF1355E 题意\n有 $N$ 个柱子，高度分别为 $h_1, h_2, \u0026hellip; h_N$。现在有3种操作：\n 令一个柱子的高度+1，cost为 $A$ 令一个柱子的高度-1，cost为 $R$ 令一个柱子的高度+1，且令另外一个柱子的高度-1，cost为 $M$  求最小的cost使得所有柱子高度相等？\n其中 $1 \\leq N \\leq 10^5, 0 \\leq h_i \\leq 10^9$\n 题解 如果我们枚举最终的高度 $h$，对于每一个 $h$ 都可以在 $\\log(N)$ 的时间内计算出来对应的 $cost$。\n然后我们会发现，随着 $h$ 的增加，$cost$ 是一个二次函数，具有一个最小值。（证明略）\n所以就可以使用三分搜索了！\n 因为三分搜索的边界不太好处理，所以可以限定一个范围，在范围之内就停止搜索开始暴力枚举。\n 搜索的部分代码：\nll low = 1, high = 1e9; while (high - low \u0026gt;= 10) { ll mid = (low + high) \u0026gt;\u0026gt; 1; ll lmid = mid-1, rmid = mid+1; ll lv = solve(lmid), rv = solve(rmid); if (lv \u0026gt; rv) low = lmid; else high = rmid; } for (ll p = low; p \u0026lt;= high; p++) { ll r = solve(p); ans = min(ans, r); }  ","date":"2021-03-05T22:20:54+08:00","permalink":"https://tom0727.github.io/post/020-%E4%B8%89%E5%88%86%E6%B3%95/","tags":["三分搜索"],"title":"三分法"},{"categories":["题解"],"contents":"题目链接 https://www.luogu.com.cn/problem/P1450\n题意\n有 $n$ 种烹饪方法，$m$ 种主要食材。每道菜都只用 恰好一种 烹饪方法和主要食材，同时对于 每种烹饪方法 $i$ 和 主要食材 $j$，有 $a_{ij}$ 种不同的菜。所以总共有 $\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^m a_{ij}$ 道不同的菜。\n现在需要求做菜方案 （设总共有 $k$ 道菜，$k$ 可以取任何数），满足：\n $k \\geq 1$ 每道菜的烹饪方法 $i$ 各不相同 每种主要食材 $j$ 最多在一半（$\\lfloor \\frac{k}{2} \\rfloor$）的菜中出现  求满足上述条件的做菜方案个数？\n$1 \\leq n \\leq 100, 1 \\leq m \\leq 2000, 0 \\leq a_{ij} \u0026lt; 998244353$\n 题解 首先考虑条件1和2，满足这些条件的总方案数有 $((s_1+1) * (s_2+1) * (s_3+1) * \u0026hellip; * (s_n+1) - 1)$ 种，其中 $s_i = \\sum\\limits_{j=1}^m a_{ij}$\n（因为对于每种烹饪方法 $i$，还可以 不选，所以是 $(s_i+1)$，最后减去 全部不选 的情况）\n这样，我们减去 不满足条件3 的方案数即可！\n我们枚举超过限制的主要食材 $j$，然后设 $dp[i][k]$ 为：当前到了第 $i$ 种烹饪方法，使用了 $k$ 种主要食材 $j$ 的方案数。\n那么问题关键在于，对于某一种烹饪方法 $i$，我们可以不选任何菜，这怎么办？\n我们假设有 $t$ 个不选的，那么总共就选了 $n-t$ 个菜，要保证 $k \u0026gt; \\lfloor \\frac{n-t}{2} \\rfloor$，即 $2k + t \u0026gt; n$。\n所以，我们可以改变一下状态的定义，我们可以将 不选 变成 选了一种主要食材 $j$，而 选择主要食材 $j$ 就变成 选择了两个主要食材 $j$。这样，只要满足 不选的数量 + 2 * 选择主要食材 \u0026gt; n，就不满足条件3了！\n转移方程就很好写了，对于每一种烹饪方法 $i$，有 $3$ 种决策方案：\n 选择主要食材 $j$：dp[i][k] += dp[i-1][k-2] * a[i][j]; 不选任何菜： dp[i][k] += dp[i-1][k-1]; 选择非主要食材：dp[i][k] += (dp[i-1][k] * (sum[i] - a[i][j]));   注意，不能将 dp 数组变成一维然后倒序转移！\n比如，在第三种转移时，(sum[i] - a[i][j]) == 0，那么如果是二维的，此时 dp[i][k] = 0，而如果是一维的，就会变成 dp[i][k] = dp[i-1][k]。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 998244353; const int maxn = 1e5+5; ll dp[103][205]; ll sum[105]; ll a[103][2003]; int n,m; int main() { fastio; ll ans = 1; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j]; sum[i] = (sum[i] + a[i][j]) % mod; } ans = (ans * (sum[i]+1LL)) % mod; } ll delta = 1LL; for (int j = 1; j \u0026lt;= m; j++) { memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int k = 0; k \u0026lt;= 2*n; k++) { dp[i][k] = (dp[i][k] + dp[i-1][k] * (sum[i] - a[i][j]) % mod) % mod; if (k \u0026gt;= 1) { (dp[i][k] += dp[i-1][k-1]) %= mod; } if (k \u0026gt;= 2) { dp[i][k] = (dp[i][k] + dp[i-1][k-2] * a[i][j] % mod) % mod; } } } for (int k = n+1; k \u0026lt;= 2*n; k++) (delta += dp[n][k]) %= mod; } ans -= delta; (ans %= mod) += mod; ans %= mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  ","date":"2021-03-05T14:58:19+08:00","permalink":"https://tom0727.github.io/post/019-luogu-p5664/","tags":["数学","计数","dp"],"title":"Luogu P5664 Emiya家今天的饭（计数，dp）"},{"categories":["题解"],"contents":"题目链接 https://www.luogu.com.cn/problem/P1450\n题意\n共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$\n某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚的 第 $i$ 种硬币，想购买价值为 $s$ 东西（不设找零）。请问每次有多少种付款方法。\n其中，$1 \\leq c_i,d_i,s \\leq 10^5, 1 \\leq n \\leq 1000$\n 题解 先考虑每个硬币有 无限 个的情况。\n设 $dp[i][j]$ 为：使用 前 $i$ 种硬币，购买 价值为 $j$ 的物品的方案数，那么有：\n$dp[i][j] = \\sum\\limits_{k=1}dp[i-1][j-c_i*k]$。\n很明显，这是一个 无穷背包，所以可以直接优化为：\ndp[0] = 1; for (int i = 1; i \u0026lt;= 4; i++) { for (int j = 1; j \u0026lt;= 1e5; j++) { if (j - c[i] \u0026gt;= 0) dp[j] += dp[j-c[i]]; } }  那么，现在考虑 只有一种硬币有限制 的情况：\n由于 $dp[j]$ 都是从 $dp[j-c_i]$ （实际上就是从 $dp[j-k*c_i]$）转移过来的，那么我们只要把 硬币超出限制的转移情况 删掉即可！\n所以，$dp[j] - dp[(d_i+1) * c_i]$ 就是答案了！\n那么如果 多个硬币有限制 呢？考虑 容斥 ！\n假设有 $3$ 种硬币，那我们就 减去 $1$ 种硬币超限的情况，加上 $2$ 种硬币超限的情况，减去 $3$ 种硬币超限的情况。\n枚举这些情况，使用 bitmask 即可！(具体的见代码)\n 容斥中，每一项的符号根据 bitmask 中 bit 的个数来决定！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e5+5; ll dp[maxn]; int arr[5]; int d[5]; int q,s; int main() { for (int i = 1; i \u0026lt;= 4; i++) cin \u0026gt;\u0026gt; arr[i]; cin \u0026gt;\u0026gt; q; dp[0] = 1; for (int i = 1; i \u0026lt;= 4; i++) { for (int j = 1; j \u0026lt;= 1e5; j++) { if (j - arr[i] \u0026gt;= 0) dp[j] += dp[j-arr[i]]; } } while (q--) { for (int i = 1; i \u0026lt;= 4; i++) cin \u0026gt;\u0026gt; d[i]; cin \u0026gt;\u0026gt; s; ll ans = dp[s]; for (int mask = 1; mask \u0026lt;= (1\u0026lt;\u0026lt;4)-1; mask++) { // 枚举容斥 int cnt = 0; int cur = 0; for (int j = 1; j \u0026lt;= 4; j++) { if (mask \u0026amp; (1\u0026lt;\u0026lt;(j-1))) { cur += ((d[j]+1) * arr[j]); cnt++; // 判断加号还是减号 } } if (s \u0026gt;= cur) { if (cnt \u0026amp; 1) ans -= dp[s - cur]; else ans += dp[s - cur]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   其他例题(TODO) ","date":"2021-03-04T23:29:54+08:00","permalink":"https://tom0727.github.io/post/018-luogu-p1450/","tags":["数学","计数","容斥"],"title":"Luogu P1450 硬币购物（计数，容斥）"},{"categories":["算法"],"contents":"记录一些组合数学的公式。\n公式 组合数 $C(n,m)$  $C_n^0 = C_n^n = 1$ $C_n^k = C_{n-1}^k + C_{n-1}^{k-1}$ $C_n^k = \\frac{n!}{k!(n-k)!}$   注：$0! = 1, (0!)^{-1} = 1$\n 证明公式2 $n$ 个中选 $k$ 个， 考虑 $n$ 个元素中的第一个元素：\n 如果它被选中，有 $C_{n-1}^{k-1}$ 种。 如果它没有被选中，有 $C_{n-1}^k$ 种。    二项式定理 $(a+b)^n = \\sum\\limits_{k=0}^n C_n^ka^kb^{n-k}$\n 卡特兰数 (Catalan) 通项公式：\n $H_n = 1 ~ (n=0,1)$\n  $H_n = \\frac{C_{2n}^n}{n+1}~(n \\geq 2)$\n  $H_n = C_{2n}^n - C_{2n}^{n-1}$\n  递推式：\n  $H_n = \\sum\\limits_{i=0}^{n-1}H_{i}H_{n-i-1} = H_0H_{n-1} + H_1H_{n-2} + \u0026hellip; + H_{n-1}H_0$\n  $H_n = \\frac{(4n-2)}{n+1} H_{n-1}$\n   第二类斯特林数 $S(n,m)$ 代表将 $n$ 个不同的小球，放进 $m$ 个相同，非空盒子的方案数\n通项公式：\n$S(n,m) = \\sum\\limits_{i=0}^m (-1)^{m-i}\\frac{i^n}{i!(m-i)!}$\n递推式：\n$S(n,m) = m*S(n-1,m) + S(n-1,m-1)$\n证明 考虑第一个小球，有两种情况：\n 独占一个盒子：相当于，其他 $n-1$ 个小球要放进 $m-1$ 个盒子中，且盒子不为空，所以为 $S(n-1,m-1)$ 不独占一个盒子：相当于，先将其他 $n-1$ 个小球放进 $m$ 个盒子中，且盒子不为空，然后从 $m$ 个盒子中选一个，把当前小球放进去，所以为 $m*S(n-1,m)$   经典例题 例1 男女生排列问题 题意\n三个女生和五个男生站成一排。\n  如果女生必须全排在一起，有多少种排法？\n  如果女生不能相邻，有多少种排法？\n  如果两端都不排女生，有多少种排法？\n  如果两端不都排女生，有多少种排法？\n   第一题答案 将3个女生看作1个，所以就有 $A_6^6$ 种。对于女生内部的排列有 $A_3^3$ 种。所以总共为 $A_6^6A_3^3$ 种。\n 第二题答案 先排男生，有 $A_5^5$ 种，然后将女生插入6个空位中，有 $A_6^3$ 种。所以总共为 $A_5^5A_6^3$ 种。\n 第三题答案 先排好两个男生在两边，有 $A_5^2$ 种，两个男生中间的人就可以随便排了，就有 $A_6^6$ 种。所以总共为 $A_5^2A_6^6$ 种。\n也可以这么想，让女生在中间的6个位置先选好3个，有 $A_6^3$ 种，剩下的男生随便排，有 $A_5^5$ 种。所以总共为 $A_6^3A_5^5$ 种，答案和上面一样。\n 第四题答案 所有排列情况有 $A_8^8$ 种，如果两边都排女生，有 $A_3^2A_6^6$ 种。所以总共为 $A_8^8 - A_3^2A_6^6$ 种。\n  例2 小球放盒子问题 假设有 $n$ 个小球，$m$ 个盒子。\n小球无区别-盒子无区别-不允许空盒 略（还没遇到）\n 小球无区别-盒子无区别-允许空盒 略（还没遇到）\n 小球无区别-盒子有区别-不允许空盒 使用隔板法，在 $n$ 个小球中间放置 $m-1$ 块挡板，将小球分为不为空的 $m$ 部分。小球之间的空位有 $n-1$ 个。所以答案为\n$C_{n-1}^{m-1}$\n 小球无区别-盒子有区别-允许空盒 先多加 $m$ 个小球，转化为 不允许空盒 的问题后，再把多加的 $m$ 个小球拿出来即可。所以答案为\n$C_{n+m-1}^{m-1}$\n 小球有区别-盒子无区别-不允许空盒 答案就是第二类斯特林数 $S(n,m)$，递推式如上：\n$S(n,m) = m*S(n-1,m) + S(n-1,m-1)$\n 小球有区别-盒子无区别-允许空盒 在 不允许空盒 的基础上，枚举一下 空盒的个数。所以答案为\n$\\sum\\limits_{i=1}^{\\min(n,m)}S(n,i)$\n 小球有区别-盒子有区别-不允许空盒 在 盒子无区别 的基础上，乘上盒子的排列 $m!$ 即可，所以答案为：\n$S(n,m) * m!$\n 小球有区别-盒子有区别-允许空盒 每个小球可以随便选，互不影响，所以答案为：\n$n^m$\n  例3 错排问题 题意\n有 $1,2,3,\u0026hellip;,n$ 这些数字，重新排序使得不存在任何一个数字的位置和原来相同，有多少种方法？\n 答案 $D_n = (n-1)(D_{n-1} + D_{n-2})$，其中 $D_1 = 0, D_2 = 1$\n证明：初始情况下如图：\n在图中，上下两行对应的元素需要错开。我们设这种情况下，排序的方法有 $f(n)$ 种。\n对于元素 $1$，我们可以选择除 $1$ 以外的任何一个元素，所以有 $n-1$ 种。\n假设我们选了 $1 \\rightarrow 2$，就会变成下图：\n那么，再看元素 $2$：\n  如果 $2 \\rightarrow 1$，那么就会变成下图，即 $f(n-2)$ 种。   如果 $2 \\rightarrow 3 ~ or ~ 4 ~ or ~ \u0026hellip; ~ n$，就相当于 $2$ 和 $1$ 必须错开，那就相当于下图，即 $f(n-1)$ 种。\n  所以最终就可以得到 $f(n) = (n-1)(f(n-1) + f(n-2))$\n","date":"2021-03-02T18:35:43+08:00","permalink":"https://tom0727.github.io/post/017-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","tags":["数学"],"title":"组合数学"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_f\n题意\n初始时有个函数 $f(x) = 0$，现在有 $Q$ 个询问，询问有两种：\n1 a b：令 $f(x) = f(x) + |x-a| + b$\n2：求 $x$ 使得 $f(x)$ 最小，并求出这个 $f(x)$ 的最小值\n 题解 $f(x)$ 必然长这样：$f(x) = |x-a_1| + |x-a_2| + \u0026hellip; + |x-a_n| + \\sum\\limits_{i=1}^{n}b_i$\n要让 $f(x)$ 最小，就令 $x$ 等于 $a_1,a_2,\u0026hellip;,a_n$ 的中位数。\n那么已知中位数 $a_k$ 的话，如何找到 $\\sum\\limits_{i=1}^{n} |a_k - a_i|$ ？\n假设 $n$ 为奇数，那如果我们将 $a_i$ sort 一下，有：\n$\\sum\\limits_{i=1}^{n} |a_{\\frac{n+1}{2}} - a_i| = \\sum\\limits_{i=1}^{\\frac{n}{2}}(a_{\\frac{n+1}{2}+i} - a_{\\frac{n+1}{2}-i})$\n如果我们分开维护中位数 $a_{\\frac{n+1}{2}}$ 左右两边的 sum 就可以 $O(1)$ 求和了！\n 用对顶堆！\n我们维护两个 multiset\u0026lt;ll\u0026gt;，一个是大顶堆（叫做small），维护小于等于中位数的部分。一个是小顶堆（叫做big），小顶堆维护大于等于中位数的部分，并且保证两者的 size 之差 $\\leq 1$。\n 插入新值的时候，就和当前中位数比较一下，如果小于等于中位数就插入small，否则插入big，然后看一下size之差，如果 size之差 $\u0026gt; 1$ 就从多的那个堆取出来，插入另外一个堆，这样就动态调整了中位数。\n 这样我们可以 $O(1)$ 求出中位数，并且 $\\sum\\limits_{i=1}^{n} |a_k - a_i|$ 也可以 $O(1)$ 得出，用big的$sum$ 减去 small的 $sum$ 即可。（写的时候需要讨论一下 size 之差为 1,0,-1 的三种情况）。\n细节部分直接看代码吧。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e3+5; const int maxm = 2e5+10; ll c = 0, ssum = 0, bsum = 0; multiset\u0026lt;ll\u0026gt; big; multiset\u0026lt;ll, greater\u0026lt;ll\u0026gt; \u0026gt; small; void ins(ll a, ll b) { c += b; if (!small.size()) { ssum += a; small.insert(a); return; } if (a \u0026lt;= *small.begin()) { small.insert(a); ssum += a; } else { big.insert(a); bsum += a; } if (small.size() \u0026gt; big.size() + 1) { auto p = small.begin(); bsum += *p, ssum -= *p; big.insert(*p); small.erase(p); } if (big.size() \u0026gt; small.size() + 1) { auto p = big.begin(); bsumssum += *p; small.insert(*p); big.erase(p); } } void query() { ll ans = bsum if (small.size() == big.size()) { cout \u0026lt;\u0026lt; *small.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return; } if (small.size() == big.size() + 1) { ans += *small.begin(); cout \u0026lt;\u0026lt; *small.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return; } if (big.size() == small.size() + 1) { ans -= *big.begin(); cout \u0026lt;\u0026lt; *big.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } int main() { fastio; int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ins(a,b); } else { query(); } } }   其他例题(TODO)  https://www.luogu.com.cn/problem/P3644  ","date":"2021-03-01T21:35:11+08:00","permalink":"https://tom0727.github.io/post/016-at-abc127f/","tags":["数据结构","堆"],"title":"Atcoder ABC 127F（对顶堆动态维护中位数）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_e\n题意\n给定一个矩阵，包含 $N \\times M$ 个格子，现在从中选出 $K \\leq N \\times M$ 个不同的格子，记为 $(x_1,y_1), (x_2, y_2), \u0026hellip; , (x_K, y_K)$ ，记\n$cost = \\sum\\limits_{i=1}^{K-1}\\sum\\limits_{j=i+1}^{K}(|x_i-x_j| + |y_i-y_j|)$\n求：对于所有不同的 $K$ 个格子的选法，$cost$ 的sum为多少？\n 法一概率 选 $k$ 个格子的方案数为 $C(n+m, k)$，在 $k$ 个格子中，任选 $2$ 个出来，有 $C(k,2)$ 种，考虑它们的贡献：\n因为是全部方案，所以可以考虑用 期望值 来做！\n问题转化为，从 $N \\times M$ 的矩阵中，选择 $2$ 个不同的点 $(x_i, y_i), (x_j,y_j)$ ，求 $|x_i - x_j| + |y_i-y_j|$ 的期望？\n期望为： $\\frac{n+m}{3}$\n 如果推式子很难，这里是一些小技巧（仅用于 分母中无 $n,m$ ，并且分子中不存在 $nm$ 之类的项）：\n 打表找规律：假设期望值 $E(n,m)$ 是一个关于 $n,m$ 的多项式，那么固定一下 $n$ 的值，然后让 $m = 1,2,3\u0026hellip;$ 来打表找出 $E(n,m)$ 和 $m$ 的关系。同理可以找出 $E(n,m)$ 和 $n$ 的关系，相加一下就可以了。\n  拉格朗日插值法：设 $ans = F(n,m) = E(n,m) * C(nm, 2)$，我们可以固定 $n$，然后用插值法找出 $F(n,m)$ 和 $m$ 的关系。（这个函数有两个变量，按理说应该是固定每一个 $n$ 然后对每一个 $n$ 都进行一次插值法的，以后遇到了可以尝试一下。）\n  严谨证明：\n考虑一个点 $(x,y)$，那么\n纵向贡献 为： $v_{x,y} = [(1+2+\u0026hellip;+x-1) + (1+2+\u0026hellip;+n-x)] * m$\n横向贡献 为： $h_{x,y} = [(1+2+\u0026hellip;y-1) + (1+2+\u0026hellip;+m-y)] * n$\n期望就是 $E(n,m) = \\frac{\\sum\\limits_{x=1}^n \\sum\\limits_{y=1}^m (v_{x,y} + h_{x,y})}{C(nm,2)} = \\frac{n+m}{3}$\n 以上，最终的答案就是\n$ans = C(nm,k) * C(k,2) * \\frac{n+m}{3}$\n 法二计数 我们选择 $2$ 个格子，有 $C(nm-2, k-2)$ 种。\n对于横坐标的差值为 $d_x$ 的情况，有 $(n-d_x) m^2$ 种。贡献就是 $(n-d_x)m^2*d_x$\n对于纵坐标的差值为 $d_y$ 的情况，有 $(m-d_y) n^2$ 种。贡献就是 $(m-d_y) n^2*d_y$\n所以答案就是\n$ans = C(nm-2, k-2) (\\sum\\limits_{d_x=1}^{n-1} (n-d_x)m^2*d_x + \\sum\\limits_{d_y=1}^{m-1} (m-d_y)n^2*d_y)$\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 2e5+5; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; (a *= a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } ll inv(ll a) { return qpow(a, mod-2); } ll n,m,k; ll fac[maxn]; void init() { fac[0] = 1; fac[1] = 1; for (int i = 2; i \u0026lt;= n*m; i++) { fac[i] = (fac[i-1] * (ll)(i)) % mod; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; init(); ll nu = fac[n*m] * k % mod * (k-1) % mod * (n+m) % mod; ll de = inv(fac[k]) * inv(fac[n*m-k]) % mod * inv(6) % mod; cout \u0026lt;\u0026lt; (nu * de) % mod \u0026lt;\u0026lt; endl; }   参考链接  https://blog.csdn.net/weixin_30323631/article/details/96351727 https://blog.csdn.net/qq_40655981/article/details/90642350  一些数学知识 Q1. 如果不限定坐标为整数，长度为 $n$ 的线段上任取两个点，距离期望值是？\nA1. 答案为 $\\frac{n}{3}$，有两种方法。\n第一种：先假设坐标只能为 $1,2,\u0026hellip;,n$ 的整数，那么求出的期望是 $E_n = 2\\times \\frac{\\sum\\limits_{i=1}^{n}i(n-i)}{n^2} = \\frac{n^2-1}{3n}$，取一个 $n$ 趋向无穷，就有 $E = \\lim_{n \\to \\infty} \\frac{n^2-1}{3n} = \\frac{n}{3}$\n 上述推导需要用到 $1^2 + 2^2 + \u0026hellip; + n^2 = \\frac{1}{6}n(n+1)(2n+1)$\n 第二种：先假设线段长度为 $1$，则有期望为 $\\frac{\\int_{0}^1 \\int_{0}^1 |x-y| ~dydx}{\\int_{0}^1 \\int_{0}^1 1~ dydx} = \\int_{0}^1 \\int_{0}^x (x-y) ~ dydx + \\int_{0}^1 \\int_{x}^1 (y-x) ~dydx = \\frac{1}{3}$，对于线段长度为 $n$，乘上 $n$ 即可。（记得分母要除以样本空间，即 $\\int_{0}^1 \\int_{0}^1 1~ dydx$）\n Q2. 如果不限定坐标为整数，$n \\times n$ 的正方形中任取两个点，距离期望值是？\nA2. 答案约为 $0.521$，具体分析可以见 这里 和 这里\n其他例题(TODO)  https://www.luogu.com.cn/problem/P4781  ","date":"2021-02-28T23:20:51+08:00","permalink":"https://tom0727.github.io/post/015-at-abc127e/","tags":["数学","计数","概率"],"title":"Atcoder ABC 127E（数学，计数，概率）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc162/tasks/abc162_e\n题意\n给定 $2 \\leq N \\leq 10^5, 2 \\leq K \\leq 10^5$，现有长度为 $N$ 的序列 $\\{ a_1, a_2, \u0026hellip;, a_N \\}$，其中 $1 \\leq a_i \\leq K$\n这样的序列总共有 $K^N$ 个，求所有这些序列的 $\\sum \\gcd(a_1,a_2,\u0026hellip;,a_N)$？\n 题解 发现我们可以根据 $\\gcd$ 的值进行枚举，我们设 $\\gcd(a_1,a_2,\u0026hellip;,a_N) = x$ 的序列数量为 $d_x$，则有：\n$d_1 = K^N - d_2 - d_3 - \u0026hellip; - d_k$\n那么 $d_2$ 呢？我们发现如果 $\\gcd(a_1,a_2,\u0026hellip;,a_N) = 2$，则所有的 $a_i$ 必然为 2的倍数，所以每个位置上有 $\\frac{K}{2}$ 种选法，即：\n$d_2 = (\\frac{K}{2})^N - d_4 - d_6 - \u0026hellip; - d_{\\frac{K}{2} \\times 2}$\n同理有：\n$d_3 = (\\frac{K}{3})^N - d_6 - d_9 - \u0026hellip; - d_{\\frac{K}{3} \\times 3}$\n\u0026hellip;\n$d_K = 1$\n这样，直接用一个 dp[] 记录一下 $d_x$ 的值，然后倒着枚举，暴力计算即可。\n最终的答案为 $\\sum\\limits_{i=1}^K i \\times dp[i]$\n时间复杂度：$T(K) = K + \\frac{K}{2} + \\frac{K}{3} + \u0026hellip; + \\frac{K}{K} = K(1+\\frac{1}{2}+\\frac{1}{3}+\u0026hellip;+\\frac{1}{K})$\n发现这个是 harmonic series 的和，复杂度大概为： $1+\\frac{1}{2}+\\frac{1}{3}+\u0026hellip;+\\frac{1}{K} = O(\\log k)$\n所以最终时间复杂度是 $O(K\\log K)$\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 1e5+5; int n,k; ll dp[maxn], ans = 0; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; b \u0026gt;\u0026gt;= 1; (a *= a) %= mod; } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = k; i \u0026gt;= 1; i--) { ll d = 0; for (int j = 2; i * j \u0026lt;= k; j++) { d += dp[i*j]; } d %= mod; ll r = qpow(k/i, n); dp[i] = (r-d+(ll)mod) % mod; ans = (ans + (ll)(i) * (ll)(dp[i])) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   一些拓展 在洛谷上看题解的时候，看到了莫比乌斯反演的方法，如果未来学了的话可以重新来做一下，loj上有加强版的题目 ($K \\leq 10^{11}$)\n其他例题(TODO)  https://loj.ac/p/6491 (需要莫比乌斯反演)  ","date":"2021-02-27T14:59:58+08:00","permalink":"https://tom0727.github.io/post/014-at-abc162e/","tags":["数学","计数"],"title":"Atcoder ABC 162E（数学，计数）"},{"categories":["算法"],"contents":"定义 最小环：指图中的一个环，它不包含任何更小的环。\n在无向图中，最小的最小环为3个节点。在有向图中，最小的最小环为2个节点。（不考虑self-loop的情况）\n无权无向图求最小环 例题: https://codeforces.com/contest/1364/problem/D\n题意\n给定一个 connected undirected graph:\n$n$个vertex, 和一个int $k$, 其中 $3 \\leq k \\leq n$, 请找出 以下的其中之一:\n  一个独立集(set of vertex， 两两之间没有edge)， 包含 $\\lceil\\frac{k}{2}\\rceil$ 个vertex\n  一个simple cycle (set of vertex, 不包含重复vertex)， 其中 $len \\leq k$\n   题解   如果这是一个tree ($m = n-1$), 则 (1)很容易找, 只要dfs一下，做一个图的染色 (染成 $0,1$)即可, 最后取 全部的 $0$ 或者 全部的 $1$\n  如果不是tree, 必然存在cycle, 那么我们可以找到一个最小环, 最小环必然满足 (1) 或者 (2)！（易证）\n  •怎么找最小环? 用DFS!\n 维护一个环的长度 len 维护一个 dep[] 数组, 代表每个vertex的depth 维护一个 pre[] 数组, pre[u] 代表dfs过程中 u的parent 维护一个 int c, 代表找到的cycle的 终点!  然后，\n  从vertex 1开始dfs， dep[to] = dep[cur] + 1 这样来更新 dep[]\n  当我们找到一个backward edge时, 更新最小环长度\nlen = min(len, abs(dep[to] - dep[cur]) + 1))  并且更新c, 使得 c = cur, 然后继续探索！\n  dfs结束后, 直接用\nvector\u0026lt;int\u0026gt; cycle; void findcycle() { while (len--) cycle.push_back(c), c = pre[c]; }  即可找到最小环！\n  时间复杂度：$O(n+m)$\n 无权有向图求最小环 例题：https://atcoder.jp/contests/abc142/tasks/abc142_f\n题意\n给定一个 directed graph，求它的一个 subgraph 满足：\n $V'$ 是 $V$ 的 non-empty subset $E'$ 是 $E$ 中，所有两端均在 $V'$ 内的edges $V'$ 中，所有的 vertex 的 in-degree 和 out-degree 均为1   题解 易知，最小环满足这个条件！\n如何求最小环？可以用 $N$ 次 DFS！\n 维护 ed 代表环的终点，维护最小环长度 final 维护一个 dep[] 数组, 代表每个vertex的depth 维护一个 par[] 数组, par[u] 代表dfs过程中 u的parent 维护一个 in[] 数组，代表在dfs过程中，当前的某个vertex是否存在于递归stack中！  dfs过程如下：\nint n,m, dep[maxn], par[maxn]; int ans = 1e9, ed = -1, final = 1e8; vector\u0026lt;int\u0026gt; cycle; bool in[maxn]; void dfs(int cur) { in[cur] = 1; dep[cur] = dep[par[cur]] + 1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (dep[to]) { if (in[to]) { // 必须得在递归栈内 int res = abs(dep[cur] - dep[to]) + 1; if (res \u0026lt; ans) { ans = res; ed = cur; } } } else { par[to] = cur; dfs(to); } } in[cur] = 0; }   为什么要加 in[] 数组？\n 如下图：\n我们需要保证这个环必然全部同时出现在递归stack内，否则可能会出问题！\n（如上图，如果不考虑 in[] 数组的话，就有可能错误的把 1-\u0026gt;3-\u0026gt;2 当作一个环！\n 为什么要使用 $N$ 次 dfs ？\n 如下图：\n如果我们从 $1$ 开始进行 dfs，那么如果是按照图上的访问顺序，会导致我们找不到最小环！\n但是如果从 $7$ 开始进行 dfs，就可以找到了！\n所以我们需要每一个点都开始一次dfs，总共 $N$ 次 dfs。\n 注：优化：可以在每次dfs中找到的环中找最小环，如果不是环中的节点，就不需要考虑了。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define abs(a) ((a\u0026gt;0)?a:-(a)) const int mod = 1e9+7; const int maxn = 1e3+5; const int maxm = 2e3+10; struct Edge { int to,nxt; } edges[maxm]; int head[maxn], ecnt = 1; int n,m, dep[maxn], par[maxn]; int ans = 1e9, ed = -1, final = 1e8; vector\u0026lt;int\u0026gt; cycle; bool in[maxn]; void add(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); } } void dfs(int cur) { in[cur] = 1; dep[cur] = dep[par[cur]] + 1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (dep[to]) { if (in[to]) { int res = abs(dep[cur] - dep[to]) + 1; if (res \u0026lt; ans) { ans = res; ed = cur; } } } else { par[to] = cur; dfs(to); } } in[cur] = 0; } void renew() { fill(dep, dep+n+1, 0); fill(par, par+n+1, 0); fill(in, in+n+1, 0); ans = 1e9; } int main() { fastio; init(); for (int i = 1; i \u0026lt;= n; i++) { dfs(i); if (ans \u0026lt; final) { final = ans; cycle.clear(); while (ans--) cycle.push_back(ed), ed = par[ed]; } renew(); } if (final == 1e8) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else { cout \u0026lt;\u0026lt; final \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int a : cycle) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   有权图求最小环 Floyd $O(n^3)$ 可求！\n","date":"2021-02-25T23:41:02+08:00","permalink":"https://tom0727.github.io/post/013-%E6%9C%80%E5%B0%8F%E7%8E%AF/","tags":["图论","最小环","dfs"],"title":"最小环"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1492/problem/E\n题意\n给定一个 directed and weighted graph，$2 \\leq n \\leq 2\\cdot10^5, 2 \\leq m \\leq \\min(2\\cdot10^5, n(n-1))$，每个vertex的 out-degree 最多为 $1\\leq k \\leq 9$，每个edge的weight均不相同。\n现在定义一个tuple $(c_1,c_2,\u0026hellip;,c_k)$，其中， $\\forall j \\in [1,k]$，有 $1\\leq c_j \\leq j$。\n且对于所有 out-degree 等于 $j$ 的vertex，只保留它的out-going edges中，weight第 $c_j$ 小的那个edge。\n 例如，对于vertex 5，有 $3$ 条out-going edges (以(u,v,w)的形式)： $(5,2,233), (5,4,25), (5,6,999)$\n如果 $c_3 = 1$，因为 vertex 5 具有 out-degree = $3$，所以 $c_3$ 生效，因为 $c_3 = 1$，所以保留第 $1$ 小的edge，也就是$(5,4,25)$。\n 现在求 $(c_1,c_2,\u0026hellip;,c_k)$ 的数量，使得整个图是强连通的。\n 题解 首先可以发现，因为每个edge的weight都不同，所以对于每一个vertex来说，必然只能保留最多 $1$ 个out-going edge。所以整个图中，只有 $n$ 个edge。\n又因为需要强连通，所以它只有可能是 一个环！所以只要看 每个vertex的 in-degree 是否都等于$1$即可！\n再转化一下，我们只要看在 $(c_1,c_2,\u0026hellip;,c_k)$ 的情况下，所有out-going edge所指向的vertex，并起来，形成的 可重复集合(multiset) 是否为 $\\{1,2,3,\u0026hellip;,n\\}$ 即可！\n我们可以预处理出 对于每一个 $j$，如果 $c_j = x$，所指向的vertex组成的集合。然后在枚举 $(c_1,c_2,\u0026hellip;,c_k)$ 的时候，判断一下这些集合的并集是否为 $\\{1,2,3,\u0026hellip;,n\\}$ 即可！\n那么，如何快速的\n 判断集合是否相等 和 求可重复并集 呢？  使用Hashing！\n 我们要定义一种Hash函数，使得上述两个操作的速度为 $O(1)$ 。\n在字符串哈希中，我们用字符的位置来hash，但是因为我们不关心集合中元素的顺序，所以可以用集合中元素的value来hash！\n假设给定一个集合 $\\{a_1,a_2,\u0026hellip;,a_m\\}$，定义哈希值为：$\\sum\\limits_{i=1}^mp^{a_i} = p^{a_1} + p^{a_2} + \u0026hellip; + p^{a_m}$，这样：\n 判断集合是否相等：直接比较两个集合的哈希值 求两个集合的可重复并集：直接将两个集合的哈希值相加   代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 2e5+5; const ll p = 31; int n,m,k; vector\u0026lt;pii\u0026gt; adj[maxn]; // {w, to} int out[maxn]; vector\u0026lt;int\u0026gt; deg[10]; // store vertices with deg x ll pow31[maxn]; ll ha[10][10]; //ha[i][j] 代表 c_i=j时，所指向的vertex的并集的哈希值 ll tar = 0; // {1,2,3...,n}对应的哈希值 int ans = 0; void init() { pow31[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) pow31[i] = (pow31[i-1] * p) % mod; for (ll i = 1; i \u0026lt;= n; i++) tar += pow31[i]; tar %= mod; for (int i = 1; i \u0026lt;= k; i++) { // calculate all vertex with deg i for (int j = 1; j \u0026lt;= i; j++) { // if c_i = j for (int a : deg[i]) { int to = adj[a][j-1].second; (ha[i][j] += pow31[to]) %= mod; } } } } void dfs(int dep, ll cur) { //cur: current hash value if (dep == k+1) { if (tar == cur) ans++; return; } for (int j = 1; j \u0026lt;= dep; j++) { dfs(dep+1, (cur + ha[dep][j]) % mod); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; adj[u].push_back({w,v}); out[u]++; } for (int i = 1; i \u0026lt;= n; i++) { sort(adj[i].begin(), adj[i].end()); deg[out[i]].push_back(i); } init(); dfs(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   其他例题(TODO)  https://www.luogu.com.cn/problem/P6688 https://www.luogu.com.cn/problem/P3792  ","date":"2021-02-25T15:25:22+08:00","permalink":"https://tom0727.github.io/post/012-cf-1395e/","tags":["哈希","图论"],"title":"CF 1395E(集合哈希)"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1492/problem/E\n题意\n给定 $n$ 个长度为 $m$ 的正整数array，其中 $n \\geq 2, m \\geq 1, n \\times m \\leq 250000$\n问是否存在一个array，使得这个array 与 其他每个array的difference（不同元素的个数） $\\leq 2$？\n 题解 暴搜，我们可以先令 $ans$ 等于第一个array，然后看一下其他array中，有没有 $diff \u0026gt; 2$ 的，如果有，尝试更改 $ans$ 中的一个元素，更改后再看一下其他array的difference情况，如果还是不行，就继续尝试更改其他元素。 直到所有array的 $diff \\leq 2$\n注意到，因为$ans$基于第一个array，所以最多只能更改两个元素，我们可以给在搜索的时候设置一个深度 left，代表还可以更改几个元素。一开始就是dfs(2)。\n 注1: 本题时限卡的比较紧，时限为2s，我们可以设定2s内如果搜索不出结果就直接返回\u0026quot;No\u0026rdquo;。\ndouble start = clock(); double passed = clock() - start; if (passed \u0026gt; 1950.0) { // 1950ms cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot; exit(0); }    注2: 暴搜的时候记得回溯！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; arr; vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; cnt; double start; inline bool check() { for (int i = 0; i \u0026lt; n; i++) { if (cnt[i] \u0026gt; 2) return 0; } return 1; } void dfs(int left) { if (left \u0026lt; 0) return; if (clock()-start \u0026gt; 1950) { printf(\u0026quot;No\\n\u0026quot;); exit(0); } for (int i = 0; i \u0026lt; n; i++) { cnt[i] = 0; vector\u0026lt;int\u0026gt; pos; for (int j = 0; j \u0026lt; m; j++) { if (ans[j] != arr[i][j]) { cnt[i] += 1; pos.push_back(j); } } if (cnt[i]-left \u0026gt; 2) { return; } if (cnt[i] \u0026gt; 2) { for (int j : pos) { int pre = ans[j]; ans[j] = arr[i][j]; dfs(left-1); ans[j] = pre; //记得回溯 } } } if (check()) { printf(\u0026quot;Yes\\n\u0026quot;); for (int j = 0; j \u0026lt; m; j++) printf(\u0026quot;%d \u0026quot;, ans[j]); printf(\u0026quot;\\n\u0026quot;); exit(0); } } int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); start = clock(); arr = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; (n, vector\u0026lt;int\u0026gt;(m,0)); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i][j]); } } ans = arr[0]; cnt = vector\u0026lt;int\u0026gt;(n,0); dfs(2); printf(\u0026quot;No\\n\u0026quot;); }  ","date":"2021-02-24T22:27:41+08:00","permalink":"https://tom0727.github.io/post/011-cf-1492e/","tags":["搜索","dfs优化"],"title":"CF 1492E(暴搜)"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些关于HTML,CSS,JS的知识点\nCSS 当前页面的selector 假设我们有一个nav bar，有很多个link，我们希望检测当前在哪个页面，然后让当前页面对应的link的img更换一个，怎么办？（不使用javascript，仅用CSS）\n方案 可以用CSS中的 Pseudo-classes 中的 target，当网页链接中存在 #some_id 时，所有 id = \u0026quot;some_id\u0026quot; 的tag就会变成 :target 的状态。\n所以可以给每个 a 的 href 加上一个 #some_id，然后给 img 加上 id = some_id，如下：\nHTML代码 \u0026lt;nav\u0026gt; \u0026lt;div\u0026gt; \u0026lt;a href=\u0026quot;index.html#index\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/1.jpg\u0026quot; id=\u0026quot;index\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;aboutus.html#about\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/2.jpg\u0026quot; id=\u0026quot;about\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;staff.html#staff\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/3.jpg\u0026quot; id=\u0026quot;staff\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt;   CSS代码 这里以index为例：\nnav \u0026gt; div \u0026gt; a[href*=\u0026quot;index\u0026quot;] \u0026gt; img:target { content:url(\u0026quot;images/index_selected.jpg\u0026quot;); }   参考链接  https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target  HTML/CSS 手机字体大小不一 在手机上发现font-size相同的字体大小不一致，怎么办？\n方案   在HTML文件前面加上\n\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1\u0026quot;\u0026gt;    添加上述代码后，网页中可能会出现 horizontal scrollbar。可以在css中添加：\n@media only screen and (max-width: 600px) { html, body { overflow-x: hidden; } body { position: relative; } }  然后在 media query 里面调整一下字体大小，图片大小之类的属性，保证 overflow-x: hidden; 不会隐藏内容。\n  参考链接  https://stackoverflow.com/questions/27074259/html-css-table-font-size-different-in-mobile-device https://stackoverflow.com/questions/4192277/disable-horizontal-scroll-on-mobile-web  ","date":"2021-02-21T23:39:36+08:00","permalink":"https://tom0727.github.io/post/010-%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/","tags":["前端","HTML","js","css"],"title":"HTML/CSS/JS笔记"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些关于vim的知识点\nHTML Match Tags 我们想要显示opening/closing tag的matching情况，并且从一个opening tag跳转到closing tag怎么做？\n方案  在vscode下载一个叫 Highlight Matching Tag 的插件 下载叫做 matchit 的vim插件，放在本地的 ~/.vimrc/plugin/ 下（如果没有plugin文件夹，就创建一个），在.vimrc里添加 filetype plugin on runtime macros/matchit.vim  这样就可以用 % 进行跳转了。\n vscode上似乎不能装插件，可以把cursor移动到tag上，然后按 esc 进入normal mode，然后 v a t 跳转到matching tag  参考链接  https://stackoverflow.com/questions/7281459/matchit-not-working https://vi.stackexchange.com/questions/780/how-to-jump-between-matching-html-xml-tags  ","date":"2021-02-20T23:15:28+08:00","permalink":"https://tom0727.github.io/post/009-vim/","tags":["vim"],"title":"vim笔记"},{"categories":["算法"],"contents":"介绍 树形dp就是在树上进行dp，常用于 \u0026ldquo;树上选一组点/边，满足某些条件，且使得某些权值和最大\u0026rdquo; 的问题。\n树形dp实现过程中也有很多需要注意的点，以下放一道经典例题：\n例题 例1 洛谷P2014 题意\n有 $N$ 门课程，每门课程有 $1$ 或 $0$ 门前置课程，需要上了前置课程才能上这门课。每门课 $i$ 有 $s_i$ 学分。\n现要选 $M$ 门课，使得学分总和最大。\n 题解 设 $dp[i][j]$ 为: 以 $i$ 为根的子树当中，选了 $j$ 个课程得到的最大值\n根据前置课程的关系建图(会发现这是一棵树)，因为有前置课程，所以必须选了root才能选别的，故:\n$dp[i][1] = s_i$\n在处理某一个节点i的时候，$dp[i][j]$ 代表的是： 以它为root的 \u0026ldquo;已探索\u0026rdquo; 子树中的最大值，所以在探索各个子树过程中有：\n$dp\\left[cur\\right]\\left[j\\right]=\\max\\left(dp\\left[cur\\right]\\left[j\\right],dp\\left[cur\\right]\\left[k\\right]+dp\\left[nei\\right]\\left[j-k\\right]\\right),\\ k=\\left[1,j-1\\right]$\n 实现细节\n 我们利用 $dp[i][1] = s_i$ 来处理前置课程，是非常高效的做法！ 状态转移的时候，要 倒序枚举 $j$， 也就是 $j = m \u0026hellip; 1$， 因为此时 $dp[cur][k]$ 代表的是已探索的部分，不能包括 $nei$ (因为 $nei$ 正在被探索)。为了防止同一个 $nei$ 被考虑多次，要倒序枚举！ 给定的图可能是一个森林，所以创建一个超级root $0$，并且将 $M$++ (因为 $0$ 肯定要包含进去)，最终答案就是 $dp[0][M+1]$   算法优化\n注意，在dp状态转移的时候，我们可能用的是如下loop:\nfor (int j = m; j \u0026gt;= 1; j--) { for (int k = 1; k \u0026lt;= j-1; k++) { dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  每个节点 cur 都这样loop一次，总复杂度是 $O(nm^2)$，看起来不可接受。\n我们可以优化一下：\n对于每一个root节点 cur，我们记录一下 int sz[cur]，代表 以cur为根的子树的节点数量， 这样枚举的时候我们就可以优化成这样：\nfor (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  时间复杂度：$O(n^2)$\n证明：我们考虑每一个 nei 被用来转移 的次数，会发现它只会在计算它的 parent 的dp值时才会被拿来统计，又因为每一个节点只有1个parent，所以每个节点对应的子树都只会被统计一次。\n所以时间复杂度就是 $T(\\sum\\limits_{i=1}^n i * sz[i]) = O(n^2)$\n更严谨的数学证明可以参见 https://www.luogu.com.cn/blog/Chenxiao-Yan/solution-p4322\n luogu-P2014-AC代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 305; const int maxm = 305; int n,m; int s[maxn]; int dp[maxn][maxn]; int sz[maxn]; //记录i的子树大小 struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void init() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); fill(head, head+n+2, -1); //因为存在编号为0的节点，所以初始化为-1 for (int i = 1; i \u0026lt;= n; i++) { int sc,k; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;k,\u0026amp;sc); s[i] = sc; add(k, i); } } void dfs(int cur, int par) { if (sz[cur]) return; // visited dp[cur][1] = s[cur]; sz[cur] = 1; for (int e = head[cur]; ~e; e = edges[e].nxt) { int nei = edges[e].to; if (par == nei) continue; dfs(nei, cur); sz[cur] += sz[nei]; for (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } } } } int main() { init(); m++; dfs(0, -1); printf(\u0026quot;%d\\n\u0026quot;, dp[0][m]); }    题外话：如果每门课的前置课程不止1门，就不再是一棵树了，这样的话似乎可以用状压dp来解，leetcode某次比赛中出现过。\n ","date":"2021-02-18T15:42:09+08:00","permalink":"https://tom0727.github.io/post/008-%E6%A0%91%E5%BD%A2dp/","tags":["树形dp","dp优化"],"title":"树形dp"},{"categories":["算法"],"contents":"介绍 01分数规划用于 求一个分式的极值\n例如： 给定 $a_i, b_i$，选出一组$i$， 使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大/最小？\n方法 (二分) 一般使用二分答案的方法进行求解，假设我们要求最大值，那么 二分一个答案 $mid$，有\n$\\frac{\\sum a_i}{\\sum b_i} \\geq mid$, 所以\n$\\sum a_i- (mid \\times b_i) \\geq 0$\n所以只要求出左边的最大值，判断是否 \u0026gt;= 0 即可！\n 如果左边最大值 \u0026gt;= 0，说明当前答案 $mid$ 可行，提高下边界 如果左边最大值 \u0026lt; 0，说明当前答案 $mid$ 不可行，降低上边界  例题 例1 POJ2976 Dropping tests 题意\n有 n 个物品，每个物品 $i$ 有两个权值 $a_i, b_i$。\n选 $k$ 个物品 ，使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大。\n 题解 二分答案，当前答案为 $mid$ 时，把第 $i$ 个物品的权值设为 $a_i - mid \\times b_i$，然后取最大的 $k$ 个即可得到最大值。\n 例2 洛谷P1419 题意\n给定 $n$ 个整数，求一个长度在 $[S,T]$ 之间的subarray(连续)，使得平均值最大？\n 题解 二分答案，当前答案为 $mid$ 时，我们遍历一下区间的右端点 $r$，从 $1$ 遍历到 $n$，固定一个 $r$，则我们需要找到 左端点 $l$ 使得 $\\frac{\\sum\\limits_{i=l}^ra_i}{r-l+1}$ 最大。\n令 $\\frac{\\sum\\limits_{i=l}^ra_i}{r-l+1} \\geq mid$，有 $\\sum\\limits_{i=l}^r(a_i - mid) \\geq 0$，\n定义一个新的数组$b$，其中 $b_i = a_i - mid$。\n左边的最大值就是 $b$ 这个数组中最大的连续区间，用前缀和即可。\n 另外一种思考方法:\n二分答案，当前答案为 $mid$ 时，我们遍历一下区间的右端点 $r$，从 $1$ 遍历到 $n$，固定一个 $r$，则我们需要找到 左端点 $l$ 使得 $\\frac{sum[r] - sum[l-1]}{r-l+1}$ 最大。\n$\\frac{sum[r] - sum[l-1]}{r-l+1} \\geq mid$ ，有 $(mid \\times (l-1) - sum[l-1]) - (mid \\times r - sum[r]) \\geq 0$\n因为 $r$ 固定，所以只要找 $mid*l - sum[l]$ 的最大值，其中 $l \\in [\\max(0, r-T), r-s]$。\n遍历 $r$ 的时候，维护一个单调队列即可。\n luogu-P1419-AC代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = (double)1e-6; const int maxn = 1e5+5; int n, s, t; int arr[maxn]; int sum[maxn]; double a[maxn]; int q[maxn]; int head = 0, tail = -1; double ans = -1e4; bool check(double cur) { for (int i = 0; i \u0026lt;= n; i++) a[i] = cur * (double)(i) - (double)(sum[i]); double res = -1e18; head = 0, tail = -1; for (int r = s; r \u0026lt;= n; r++) { while (head \u0026lt;= tail \u0026amp;\u0026amp; q[head] \u0026lt; r-t) head++; while (head \u0026lt;= tail \u0026amp;\u0026amp; a[q[tail]] \u0026lt; a[r-s]) tail--; q[++tail] = r-s; res = max(res, a[q[head]] - a[r]); } // for (int r = 1; r \u0026lt;= n; r++) { // double tmp = -1e18; // for (int i = max(0, r-t); i \u0026lt;= r-s; i++) { // tmp = max(tmp, a[i]); // } // res = max(res, tmp - a[r]); // } if (res \u0026gt;= 0) return 1; return 0; } int main() { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;s,\u0026amp;t); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i]); sum[i] = sum[i-1] + arr[i]; } double l = -1e4, r = 1e4; while (abs(l-r) \u0026gt; eps) { double mid = (l+r) * 0.5; if (check(mid)) { l = mid; ans = mid; } else { r = mid; } } printf(\u0026quot;%.3f\\n\u0026quot;, ans); }   例3 洛谷P4377 题意\n有 n 个物品，每个物品 $i$ 有两个权值 $a_i, b_i$。\n你可以选 $k$ 个物品 ，使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大, 且 $\\sum b_i \\geq W$\n 题解 和例1几乎一样，但是多了一个 $\\sum b_i \\geq W$ 的限制。\n设 $d_i = a_i - mid \\times b_i$，然后我们要做的事就是：\n选取一组$i$，保证在 $\\sum b_i \\geq W$ 的前提下，使得 $\\sum d_i$ 最大\n可以用01背包解决，令 $dp[n][k]$ 为：使用前 $n$ 个元素，$\\sum b_i = k$ 时， $\\sum d_i$ 的最大值。\n那么答案就是 $dp[n][W]$。\n如果在状态转移过程中出现 $k \u0026gt; W$，直接转移到 $k = W$ 的状态上即可。\n 注: 写01背包的时候不要忘了 倒序枚举 ！\n  luogu-P4377-AC代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const double eps = (double)1e-6; const int maxn = 255; int n,W; int w[maxn], t[maxn]; double dp[1001]; struct node { double d; int w; } arr[maxn]; bool check(double cur) { for (int i = 1; i \u0026lt;= n; i++) { arr[i] = {(double)t[i] - cur * (double)w[i], w[i]}; } fill(dp, dp+1001, -1e9); dp[0] = 0.0; for (int i = 1; i \u0026lt;= n; i++) { for (int d = 1000; d \u0026gt;= 0; d--) { int tar = min(d + arr[i].w, 1000); dp[tar] = max(dp[tar], dp[d] + arr[i].d); } } for (int d = W; d \u0026lt;= 1000; d++) { if (dp[d] \u0026gt;= 0.0) return 1; } return 0; } int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n,\u0026amp;W); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;w[i], \u0026amp;t[i]); } double l = 0.0, r = 1e6, ans = 0.0; while (abs(l-r) \u0026gt;= eps) { double mid = (l+r) * 0.5; if (check(mid)) { l = mid; ans = max(ans, mid); } else { r = mid; } } printf(\u0026quot;%d\\n\u0026quot;, (int)((ans+5e-5) * 1000)); }   例4 洛谷P4322 题意\n给定一棵$N$个节点的树，每个节点 $i$ 具有两个权值 $P_i, S_i$，求树中的一组节点，满足：\n $\\frac{\\sum\\limits_i P_i}{\\sum\\limits_i S_i}$ 最大 如果 节点 $i$ 被选中了，那么它的parent $R_i$ 也必须被选中 选中的节点数量 刚好为$K$  求满足条件的最大比值？\n 题解 首先看条件1：$\\frac{\\sum\\limits_i P_i}{\\sum\\limits_i S_i}$ 最大，仍然是分数规划的套路，二分答案。令 $d_i = P_i - mid \\times S_i$\n所以问题转化为求一组节点使得 $\\sum d_i$ 最大。\n然后就会发现，这是一个经典的树形dp模型，和 选课(洛谷P2014) 几乎一样。\n具体做法和注意事项见下一篇博客。\n","date":"2021-02-17T17:20:49+08:00","permalink":"https://tom0727.github.io/post/007-01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","tags":["01分数规划","二分"],"title":"01分数规划"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1159/problem/B\n题意\n给定 $n$ 个非负整数 $a_1,a_2,\u0026hellip;,a_n$，求 $\\frac{\\min(a_i, a_j)}{|i-j|}$ ？其中 $i, j \\in [1,n], i \\neq j$\n 题解 对于这类的枚举问题，一般套路都是 \u0026ldquo;固定一个数\u0026rdquo;，这里很明显是固定一下 $\\min(a_i, a_j)$。\n所以只要从 $a_1$ 遍历到 $a_n$，把当前遍历到的值作为最小值，然后不管最左侧或者最右侧元素是否小于它，直接最大化分母就可以了。\n为什么不会漏解？因为 每一个 $a_i$ 都当了一次分子！\n 代码 const int maxn = 3e5+5; int n, arr[maxn]; int ans = 1e9; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= n; i++) { int d = max(i-1, n-i); ans = min(ans, arr[i] / d); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-02-17T15:19:54+08:00","permalink":"https://tom0727.github.io/post/006-cf-1159b/","tags":["枚举"],"title":"CF1159B 题解(枚举优化)"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些爬虫相关的知识点：\n分段下载 如果我们需要设定下载的timeout怎么办？\n直接指定 requests.get() 中的 timeout 是不行的！因为这里的timeout参数意义是 \u0026ldquo;从服务器返回任意数据\u0026rdquo; 的时间差。如果我们想要设定 timeout 使得在一定时间内下载不完就break，可以用分段下载！\n分段下载由stream=True实现\ndef download_img(img_url, path): timeout = 150 # 设定150秒如果下载不完就停止下载 try: img_html = requests.get(img_url, headers=get_download_header(), timeout=10, stream=True) if img_html.status_code != 200: return body = [] start = time.time() for chunk in img_html.iter_content(1024): body.append(chunk) if time.time() \u0026gt; start + timeout: print(\u0026quot;Time out!\u0026quot;) break else: # 下载完毕 with open(path, 'wb') as file: file.write(b''.join(body)) file.flush() except BaseException as err: print(err)  多进程下载 多进程下载经常在访问一些速度较慢的网站时很有用，因为本地的带宽不是主要限制，所以可以开很多个进程同时访问然后进行下载，这样更快。\ndef f(arg): ... # 下载程序 if __name__ == '__main__': processes = [] for _ in range(20): p = multiprocessing.Process(target=f, args=(some_arg, )) p.start() processes.append(p) for p in processes: p.join()  正则表达式Regex的注意事项   匹配时注意区分懒惰匹配和贪婪匹配，懒惰匹配可以在匹配符号后加上?，如 .*?\n  如果在匹配过程中需要用到()，但是需要获取整个匹配结果（不想被()框起来的部分干扰），可以使用non-capturing group，即，(?:)，如:\nre.findall(\u0026quot;https://abc.net/images/.*?(?:jpg|png|jpeg)\u0026quot;, txt)\n这样，返回的就是整个匹配的网址，而不是()框起来的部分\n  ","date":"2021-02-10T22:52:26+08:00","permalink":"https://tom0727.github.io/post/005-%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/","tags":["爬虫","python"],"title":"爬虫笔记"},{"categories":["算法"],"contents":"定义 给定正整数$n$，求$\\varphi(n)$， 即\n 小于等于$n$ 且 与$n$互质  的正整数个数。\n性质  $\\varphi(p) = p-1, ~\\forall \\text{prime } p$ $\\varphi(mn) = \\varphi(m)\\varphi(n) \\iff \\gcd(m,n) = 1$ $\\varphi(p^k) = p^k - p^{k-1} = p^k(1-\\frac{1}{p})$ $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}, ~\\varphi(n) = n\\prod_{i=1}^{r}(1-\\frac{1}{p_i}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$ $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$, 如果 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$, 则 $\\varphi(n) = \\varphi(\\frac{n}{p_i})*p_i$  证明 证明性质1 求证： $\\varphi(p) = p-1, ~\\forall \\text{prime } p$\n 由质数的定义可知，小于等于$p$ 且 与$p$互质的数，在$[1,p]$中，除了 $p$以外均满足！\n 注： $\\varphi(1) = 1$\n 证明性质2 求证： $\\varphi(mn) = \\varphi(m)\\varphi(n) \\iff \\gcd(m,n) = 1$\n 首先，易知 $\\varphi(n) = |\\mathbb{Z}_n^{\\times}|$ , 即 $\\mathbb{Z}_n$ 中 unit(存在关于$\\bmod~ n$乘法逆元的元素)的数量\n因为 $\\mathbb{Z}_{mn} \\cong \\mathbb{Z}_m \\times \\mathbb{Z}_n \\iff \\gcd(m,n) = 1$\n所以 $\\mathbb{Z}_{mn}$的units $\\mathbb{Z}_{mn}^{\\times}$ ， 与\n$\\mathbb{Z}_m \\times \\mathbb{Z}_n$的 units $(\\mathbb{Z}_m \\times \\mathbb{Z}_n)^{\\times}$ 之间存在一个 bijection, 即\n$\\mathbb{Z}_{mn}^{\\times} \\cong (\\mathbb{Z}_m \\times \\mathbb{Z}_n)^{\\times} = \\mathbb{Z}_m^{\\times} \\times \\mathbb{Z}_n^{\\times}$\n所以 $\\varphi(mn) = |\\mathbb{Z}_{mn}^{\\times}| = |\\mathbb{Z}_m^{\\times} \\times \\mathbb{Z}_n^{\\times}| = |\\mathbb{Z}_m^{\\times}||\\mathbb{Z}_n^{\\times}| = \\varphi(m)\\varphi(n)$\n 注：\n $\\mathbb{Z}_{mn} \\cong \\mathbb{Z}_m \\times \\mathbb{Z}_n \\iff \\gcd(m,n) = 1$ 的证明见 这里 更严格的证明需要用到抽代里的中国剩余定理 （以Ring和Ideal表示的）   证明性质3 求证：$\\varphi(p^k) = p^k - p^{k-1} = p^k(1-\\frac{1}{p})$\n $\\forall n = p^k$，所有与它不互质的数$m$必然包含$p$这个质数因子，因此满足条件的$m$为：$1p, 2p, 3p, \u0026hellip; , p^{k-1}p$，共 $p^{k-1}$个。\n所以，与$n = p^k$互质的数共有 $p^k-p^{k-1}$个。\n  证明性质4 求证：$\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}, ~\\varphi(n) = n\\prod_{i=1}^{r}(1-\\frac{1}{p_i}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$\n 因为 $n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，且$p_1,p_2,\u0026hellip;,p_r$都是质数（所以两两互质）\n由性质2， $\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip;\\varphi(p_r^{k_r})$\n由性质3，$\\varphi(p_i^{k_i}) = p_i^{k_i} - p_i^{k_i-1} = p_i^{k_i}(1-\\frac{1}{p_i})$\n所以 $\\varphi(n) = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$\n  证明性质5 求证：$\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$, 如果 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$, 则 $\\varphi(n) = \\varphi(\\frac{n}{p_i})*p_i$\n 因为 $n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，\n由性质2，$\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip;\\varphi(p_r^{k_r})$\n由性质3， $\\varphi(p^k) = p^k - p^{k-1}$, 我们可以推出 $\\varphi(p^{k+1}) = \\varphi(p^{k}) * p$\n因为 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$，由上可得出 $\\varphi(p_i^{k_i}) = \\varphi(p_i^{k_i-1}) * p_i$\n即 $\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip; (\\varphi(p_i^{k_i-1})*p_i)\u0026hellip;\\varphi(p_r^{k_r}) = \\varphi(\\frac{n}{p_i})*p_i$\n  求单个数的欧拉函数值 $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，直接质因数分解，由性质4即可求出！\n时间复杂度：$O(\\sqrt n)$\n代码 ll phi(ll x) { ll res = x; for (ll p = 2; p * p \u0026lt;= x; p++) { if (x % p == 0) { res = (res / p) * (p-1); } while (x % p == 0) x /= p; } if (x \u0026gt; 1) res = res / x * (x-1); return res; }  线性筛求1~n的欧拉函数值 和线性筛的基本思路一样，只不过要分类讨论 i % p == 0 与否。（i是当前处理到的数, p是当前用到的质数）\n  如果 i % p == 0，说明 i * p 这个数里，包含了至少2个质因子$p$ (即$p^2$)。\n由性质5，有 $\\varphi(i * p) = \\varphi(i) * p$\n  如果 i % p != 0，说明 $\\gcd(i,p) = 1$。\n由性质2，有 $\\varphi(i * p) = \\varphi(i) * \\varphi(p)$\n  时间复杂度： $O(n)$\n代码 luogu-P2158-AC代码 题目链接: https://www.luogu.com.cn/problem/P2158\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244352; const int maxn = 4e4+5; int phi[maxn]; bool p[maxn]; vector\u0026lt;int\u0026gt; primes; int main() { int n; cin \u0026gt;\u0026gt; n; if (n \u0026lt;= 1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } phi[1] = 1; fill(p, p+maxn, 1); for (int i = 2; i \u0026lt;= n; i++) { if (p[i]) { phi[i] = i-1; primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= n; j++) { int cur = primes[j]; p[i*cur] = 0; if (i % cur == 0) { phi[i*cur] = phi[i] * cur; break; } else { phi[i*cur] = phi[i] * phi[cur]; } } } int ans = 3; for (int i = 2; i \u0026lt;= n-1; i++) ans += 2*phi[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例题 例1 CF1295 题意\n给定两个正整数 $a$, $m$, 求满足以下条件的 $x$ 的数量？\n $0 \\leq x \u0026lt; m$ $\\gcd(a,m) = \\gcd(a+x,m)$  其中，$1 \\leq a \u0026lt; m \\leq 10^{10}$\n 题解 设 $g = \\gcd(a,m)$，则 $g = \\gcd(a+x,m)$，所以 $\\gcd(\\frac{a+x}{g}, \\frac{m}{g}) = 1~$ 且 $~g|(a+x)$，又因为 $g|a$，所以 $~g|x$\n所以问题转化为：\n设 $c = \\frac{a}{g}, x = \\frac{m}{g}$，求 $k \\in [c,c+x)$，使得 $k$ 满足：$gcd(x, k) = 1$ 的 $k$ 的数量？\n我们会发现当 $k \u0026gt; x$ 时，因为 $\\gcd(x,k) = \\gcd(x, k-x)$，所以我们可以将 $k \\in (x,c+x)$ 的这一段，映射到 $k \\in (0,c)$ 上。\n所以最后我们要求的$k$就是： $k \\in [1,x]$ 使得 $\\gcd(k, x) = 1$，所以满足条件的 $k$ 的数量就等于 $\\varphi(x)$\n 参考链接  https://blog.csdn.net/paxhujing/article/details/51353672 https://www.luogu.com.cn/blog/JustinRochester/solution-p2158 https://blog.nowcoder.net/n/0cbf747dc0874027b5c48cf7fbf27060  后记 写这篇文章的时候出了几个数学公式上的问题:\n 如果排版炸了，可以试着在 _ 的前面加上 \\  ","date":"2021-02-06T17:23:34+08:00","permalink":"https://tom0727.github.io/post/004-euler-function/","tags":["数学","抽代"],"title":"欧拉函数"},{"categories":["算法"],"contents":"中国剩余定理 (crt) 定义 给定方程组： $$\\begin{cases} x\\equiv a_1 (\\text{mod }m_1) \\\\\nx\\equiv a_2 (\\text{mod }m_2) \\\\\n\u0026hellip; \\\\\nx\\equiv a_k (\\text{mod }m_k) \\\\\n\\end{cases}$$\n其中 $a_i \\geq 0, m_i \u0026gt; 0, a_i,m_i \\in \\mathbb{Z}$, 且 $m_i$ 之间两两互质。\n求满足条件的最小非负整数解 $x$ ？\n结论 令 $M = m_1 \\cdot m_2 ~\u0026hellip; ~m_k$, $M_i = \\frac{M}{m_i}$\n令 $M_i^{-1}$ 为 $M_i$ 在 $\\color{red} \\text{mod }m_i$ 意义下的逆元\n则，答案为: $x = \\sum\\limits_{i=1}^{k}a_iM_iM_i^{-1} ~ (\\text{mod }M)$\n证明 因为 $\\forall i \\neq j, M_i \\equiv 0 ~(\\text{mod } m_j)$\n所以 $\\forall i \\neq j, a_iM_iM_i^{-1} \\equiv 0~ (\\text{mod } m_j)$\n所以 $\\forall i, x \\equiv \\sum\\limits_{i=1}^{k}a_iM_iM_i^{-1} \\equiv a_iM_iM_i^{-1} ~ (\\bmod ~m_i)$\n又因为 $\\forall i, M_iM_i^{-1} \\equiv 1 ~(\\text{mod } m_i)$\n所以 $\\forall i, x \\equiv a_iM_iM_i^{-1} \\equiv a_i ~ (\\text{mod } m_i)$\n证明推导过程 证明推导过程 这里直接放参考链接一中的片段：\n 由于 $M = 3\\times5\\times7 = 105$\n所以最后的解就是 $x = (n_1 + n_2 + n_3) ~\\bmod ~ 105 = 233 ~ \\bmod 105 = 23$\n  例题  https://www.luogu.com.cn/problem/P3868  快速乘 在题目中，有可能出现 $\\bmod$ 接近 $1e18$ 的情况，有可能会爆 long long，所以在计算大数乘法时，要用快速乘（原理类似于快速幂）：\nll qmul(ll a, ll b) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % mod; b \u0026gt;\u0026gt;= 1; a = (a + a) % mod; } return ans; }  模版 luogu-P3868-AC代码 题目链接: https://www.luogu.com.cn/problem/P3868\n#include \u0026lt;bits/stdc++.h\u0026gt; #define fastio ios::sync_with_stdio(false); cin.tie(0); #define ll long long ll M = 1; ll qmul(ll a, ll b) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % M; b \u0026gt;\u0026gt;= 1; a = (a + a) % M; } return ans; } ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll curx = y; ll cury = x - (a/b) * y; x = curx; y = cury; return g; } ll a[15], b[15]; int k; ll crt() { ll ans = 0; for (int i = 1; i \u0026lt;= k; i++) { ll m = M / b[i]; ll x,y; exgcd(m, b[i], x, y); if (x \u0026lt; 0) x += b[i]; ans = (ans + qmul(qmul(a[i], m), x)) % M; } return ans; } int main() { fastio; cin \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= k; i++) cin \u0026gt;\u0026gt; b[i], M *= b[i]; for (int i = 1; i \u0026lt;= k; i++) { a[i] -= (a[i]/b[i]) * b[i]; //将a[i]变成正数 a[i] += b[i]; a[i] %= b[i]; } cout \u0026lt;\u0026lt; crt() \u0026lt;\u0026lt; endl; }   参考链接  https://zhuanlan.zhihu.com/p/103394468  拓展中国剩余定理 (excrt) 定义 用于 $m_1,m_2,\u0026hellip;,m_k$ 并不互质的情况\n给定方程组： $$\\begin{cases} x\\equiv a_1 (\\text{mod }m_1) \\\\\nx\\equiv a_2 (\\text{mod }m_2) \\\\\n\u0026hellip; \\\\\nx\\equiv a_k (\\text{mod }m_k) \\\\\n\\end{cases}$$\n其中 $a_i \\geq 0, m_i \u0026gt; 0, a_i,m_i \\in \\mathbb{Z}$，（$m_i$ 之间无特殊关联）\n求满足条件的最小非负整数解 $x$ ？\nIntuition 先看一些简单的例子：\n$$\\begin{cases} x\\equiv 2 ~(\\text{mod }4) \\\\\n\\\\\nx\\equiv 4 ~(\\text{mod }6) \\\\\n\\end{cases}\\Longrightarrow x \\equiv 10 ~(\\text{mod } 12)$$\n$$\\begin{cases} x\\equiv 4 ~(\\text{mod }6) \\\\\n\\\\\nx\\equiv 3 ~(\\text{mod }5) \\\\\n\\end{cases}\\Longrightarrow ~\\varnothing$$\n可以看出几个特点：\n 答案的 $\\text{mod}$ 为 $\\text{lcm}(m_1, m_2)$ 有可能无解 （若$m_1,m_2$互质则必然有解）  推导 考虑 $x$ 满足：\n$$\\begin{cases} x\\equiv a_1 ~(\\text{mod }m_1) \\\\\n\\\\\nx\\equiv a_2 ~(\\text{mod }m_2) \\\\\n\\end{cases}$$\n则有 $x = k_1m_1 + a_1 = k_2m_2 + a_2$\n 即：$k_1m_1 - k_2m_2 = a_2 - a_1$\n这个方程有解 $\\iff \\gcd(m_1,m_2) | (a_2 - a_1)$ （即 $(a_2 - a_1)$ 是 $\\gcd(m_1,m_2)$ 的倍数）。\n 如果无解，就直接退出。\n如果有解，就用 $exgcd(m_1, m_2, x\u0026rsquo;, y\u0026rsquo;)$ 解出 $k_1$ 的值。\n设 $\\gcd(m_1, m_2) = g$，则 $k_1 = x\u0026rsquo; \\cdot\\frac{a_2 - a_1}{g}$\n然后将 $k_1$ 代入 $x = k_1m_1 + a_1$，得到 $x$ 的值，答案就是 $x \\equiv (k_1m_1 + a_1) (\\text{mod ~lcm}(m_1,m_2))$\n这样，$2$个同余方程就转化为了$1$个，用同样的方法继续进行下去，即可化为一个同余方程。\n最终的 $\\text{mod}$ 数就是 $M = \\text{lcm}(m_1, m_2, m_3 \u0026hellip; , m_n)$\n模版 luogu-P4777-AC代码 题目链接: https://www.luogu.com.cn/problem/P4777\nusing namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e5+5; ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll x2 = x, y2 = y; x = y2, y = x2 - a/b * y2; return g; } ll mul(ll a, ll b, ll mod) { ll res = 0; while (b) { if (b\u0026amp;1) (res += a) %= mod; (a += a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } int n; ll a[maxn], m[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; m[i] \u0026gt;\u0026gt; a[i]; ll cura = a[1], curm = m[1]; for (int i = 2; i \u0026lt;= n; i++) { /* m1 = curm, m2 = m[i], a1 = cura, a2 = a[i] */ ll x,y; ll g = exgcd(curm, m[i], x, y); // g = gcd(curm, m[i]) ll c = a[i] - cura; // c = a2 - a1 c = ((c % m[i]) + m[i]) % m[i]; // 处理负数，注意是 mod m2 (即 m[i]) if (c % g) { // 无解 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } ll M = (m[i] * (curm / g)); // M = lcm(m1, m2) ll k = mul(x, c / g, M); // k1 = x' * (a2-a1) / g cura = (mul(k, curm, M) + cura) % M; // x = k1m1 + a1 curm = M; } cout \u0026lt;\u0026lt; (cura % curm + curm) % curm \u0026lt;\u0026lt; endl; }   注意事项   我们需要处理可能出现的负数！（比如在快速乘的时候，如果 $b$ 为负数就会炸）\n 在 $exgcd(a,b,x\u0026rsquo;,y\u0026rsquo;)$ 中，$x'$ 有可能为负数。 $c = a_2 - a_1$，则 $c$ 也有可能为负数。  那么如何处理负数？我们需要找到这个负数对应的 $\\text{mod}$为多少，我们可以在等式 $k_1m_1 - k_2m_2 = a_2 - a_1$ 中找到！\n因为我们要求的是 $k_1$ 的值，实际上 $k_1m_1 = (a_2-a_1) + k_2m_2$，即 $k_1m_1 \\equiv (a_2-a_1) \\text{ (mod } m_2)$\n所以无论是 $k_1 = x\u0026rsquo; \\cdot\\frac{a_2 - a_1}{g}$ 还是 $(a_2-a_1)$，都取一个 $\\text{mod } m_2$ 即可！\n代码段：\nll c = a[i] - cura; c = ((c % m[i]) + m[i]) % m[i]; // 处理负数，注意是 mod m2 (即 m[i]) ll k = mul(x, c / g, M); // k = ((k % m[i]) + m[i]) % m[i]; 可以处理，但是没有必要，因为快速乘中的 a 可以为负数    注意快速乘过程中的 $\\text{mod}$ ！因为快速乘求的实际上是 $x$ 的值，所以 $\\text{mod } M$，其中 M = lcm(curm, m[i])\n  我们用 cura, curm 来维护当前的 同余方程，之后记得更新一下 curm = lcm(curm, m[i])\n  参考链接  https://www.luogu.com.cn/blog/blue/kuo-zhan-zhong-guo-sheng-yu-ding-li  ","date":"2021-02-06T10:46:42+08:00","permalink":"https://tom0727.github.io/post/003-crt/","tags":["数学","中国剩余定理","crt"],"title":"中国剩余定理介绍"},{"categories":["工程"],"contents":"写博客好累啊，是我太久没有写作了吗\n这次来记录一下我第一次学习爬虫的经历\n起因 补完とにかくかわいい的番，感觉真好看啊，漫画也不错，就打算补补とにかくかわいい的生肉漫画，但是这网站广告特别多，还会检测我adblocker，禁用javascript的话漫画就加载不出来了，气死我了，一怒之下决定学习爬虫把漫画爬下来看。\n爬虫教程有很多，这里特别推荐一个Jack Cui的教程：\n [资源分享] Python3 网络爬虫：漫画下载，动态加载、反爬虫这都不叫事\n 爬 manga1001.com 这个网站设置的比较粗糙，图片都是静态加载的(F12就能看见图片链接)，根据标签soup.find_all()一下即可。对于这个网站的话，简单说一下爬虫的基本流程吧。\n基本流程\n  观察一下页面的HTML，用F12打开可以看到大致结构，如果要看源代码的话，可以选择：\n1.1. res = requests.get(url), print(res.txt) 或\n1.2. 在url前加上view-source:，然后用浏览器打开。\n  找到包含图片的tag， 找一下规律，然后用 soup.find_all() 即可。\n  获取所有章节的URL，然后分别去每个URL里抓取。\n   参考代码 import requests from bs4 import BeautifulSoup import os import random import time def create_dir(path): if not os.path.exists(path): os.makedirs(path) root_folder = '/Users/huzhenwei/Desktop/manga/' create_dir(root_folder) USER_AGENTS = [ \u0026quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\u0026quot;, \u0026quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\u0026quot;, \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\u0026quot;, \u0026quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\u0026quot;, ] # get content of one chapter def get_content(folder, prefix, url): res = requests.get(url) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('figure') i = 1 folder_name = os.path.join(folder, f'Chapter_{prefix:03}/') create_dir(folder_name) for item in items: for child in item.children: if i != 1: img_url = child.get('data-src') else: img_url = child.get('src') print(img_url) headers = random.choice(USER_AGENTS) img_html = requests.get(img_url, headers) img_name = os.path.join(folder_name, f'{i:02}.jpg') with open(img_name, 'wb') as file: file.write(img_html.content) file.flush() i += 1 time.sleep(random.uniform(0, 3.33)) # sleep random time # get manga url list def get_url_list(manga_name, url): res = requests.get(url) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('option') for i in range(len(items) - 2, -1, -1): if items[i] == items[-1]: # get manga chapter url list without duplicates items = items[i+1:] break chapter = 1 folder = os.path.join(root_folder, f'{manga_name}/') for item in items: manga_url = item.get('value') get_content(folder, chapter, manga_url) print(manga_url) chapter += 1 def main(): url1 = \u0026quot;https://manga1001.com/%e3%80%90%e7%ac%ac1%e8%a9%b1%e3%80%91%e3%83%88%e3%83%8b%e3%82%ab%e3%82%af%e3%82%ab%e3%83%af%e3%82%a4%e3%82%a4-raw/\u0026quot; name1 = 'Tonikaku_Kawaii' get_url_list(name1, url1) url2 = \u0026quot;https://manga1001.com/%e3%80%90%e7%ac%ac1%e8%a9%b1%e3%80%91%e5%b9%b2%e7%89%a9%e5%a6%b9%e3%81%86%e3%81%be%e3%82%8b%e3%81%a1%e3%82%83%e3%82%93-raw/\u0026quot; name2 = 'Umaru_Chan' get_url_list(name2, url2) main()    注: 这里用的USER_AGENT和sleep()都是为了防止被发现然后封IP\n 爬 manhuagui.com 上面那个太没挑战性了，于是我打算再爬一个。\n打开漫画网站， 发现没有图片链接，说明是动态加载的图片(用javascript加载的)，那怎么办呢？\nStep 1 先在网页里找找链接长啥样，毕竟用浏览器浏览的话，图片总是会被加载出来的，然后就能看到链接了，果然，在chrome的Elements这个tag里，我们翻到了图片链接：\n不过直接把链接复制到浏览器里打开的话会403，所以我们先搁置一下。\nStep 2 我们要获得某一话的所有图片链接，可以从图上看出似乎有一大段像是加密后的字符串，我们打开第一话和第二话的HTML，用命令行diff一下以后，会发现差异就刚好出现在这串字符串上：我们可以肯定这里面包含了图片链接相关的信息。\nStep 3 既然找到了加密串，那就要找一个钥匙来解码，看一下网页里内容不多，看起来并没有其他有用信息了，但是还有几个.js文件，一个个打开来看一下，终于在其中一个文件里找到了一大堆代码，然后这一大堆里面，有一段看起来又被加密了（有点此地无银三百两啊）： 把这段代码复制到chrome的console里，发现被自动解码了，得到了一个js函数： 我们点开这个函数，看一下里面的内容：\n函数内容 var LZString=(function(){var f=String.fromCharCode;var keyStrBase64=\u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026quot;;var baseReverseDic={};function getBaseValue(alphabet,character){if(!baseReverseDic[alphabet]){baseReverseDic[alphabet]={};for(var i=0;i\u0026lt;alphabet.length;i++){baseReverseDic[alphabet][alphabet.charAt(i)]=i}}return baseReverseDic[alphabet][character]}var LZString={decompressFromBase64:function(input){if(input==null)return\u0026quot;\u0026quot;;if(input==\u0026quot;\u0026quot;)return null;return LZString._0(input.length,32,function(index){return getBaseValue(keyStrBase64,input.charAt(index))})},_0:function(length,resetValue,getNextValue){var dictionary=[],next,enlargeIn=4,dictSize=4,numBits=3,entry=\u0026quot;\u0026quot;,result=[],i,w,bits,resb,maxpower,power,c,data={val:getNextValue(0),position:resetValue,index:1};for(i=0;i\u0026lt;3;i+=1){dictionary[i]=i}bits=0;maxpower=Math.pow(2,2);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}switch(next=bits){case 0:bits=0;maxpower=Math.pow(2,8);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}c=f(bits);break;case 1:bits=0;maxpower=Math.pow(2,16);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}c=f(bits);break;case 2:return\u0026quot;\u0026quot;}dictionary[3]=c;w=c;result.push(c);while(true){if(data.index\u0026gt;length){return\u0026quot;\u0026quot;}bits=0;maxpower=Math.pow(2,numBits);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}switch(c=bits){case 0:bits=0;maxpower=Math.pow(2,8);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}dictionary[dictSize++]=f(bits);c=dictSize-1;enlargeIn--;break;case 1:bits=0;maxpower=Math.pow(2,16);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}dictionary[dictSize++]=f(bits);c=dictSize-1;enlargeIn--;break;case 2:return result.join('')}if(enlargeIn==0){enlargeIn=Math.pow(2,numBits);numBits++}if(dictionary[c]){entry=dictionary[c]}else{if(c===dictSize){entry=w+w.charAt(0)}else{return null}}result.push(entry);dictionary[dictSize++]=w+entry.charAt(0);enlargeIn--;w=entry;if(enlargeIn==0){enlargeIn=Math.pow(2,numBits);numBits++}}}};return LZString})();String.prototype.splic=function(f){return LZString.decompressFromBase64(this).split(f)};   获得这个函数以后，我们尝试着把之前获得的加密串放进去看看： 这看起来就正常多了，而且这里面的 04|05|06|... 之类的信息看起来也能和之前找到的图片链接对应上。但是它似乎并没有按照某个特定的规律来，所以可以肯定还有一个函数来处理这个字符串。\nStep 4 有了这个信息，我们就接着找处理这个字符串的函数，再次观察一下HTML，发现这个Base64的串被包含在了一个\u0026lt;script\u0026gt;当中，长这样：\nscript内容 \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt;window[\u0026quot;\\x65\\x76\\x61\\x6c\u0026quot;](function(p,a,c,k,e,d){e=function(c){return(c\u0026lt;a?\u0026quot;\u0026quot;:e(parseInt(c/a)))+((c=c%a)\u0026gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;}('X.B({\u0026quot;y\u0026quot;:8,\u0026quot;x\u0026quot;:\u0026quot;w v u t s r\u0026quot;,\u0026quot;q\u0026quot;:\u0026quot;8.1\u0026quot;,\u0026quot;p\u0026quot;:o,\u0026quot;n\u0026quot;:\u0026quot;4\u0026quot;,\u0026quot;l\u0026quot;:[\u0026quot;j.1.2\u0026quot;,\u0026quot;A.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;9-a.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;10.1.2\u0026quot;,\u0026quot;11.1.2\u0026quot;,\u0026quot;12.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;14.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;C.1.2\u0026quot;,\u0026quot;P.1.2\u0026quot;,\u0026quot;D.1.2\u0026quot;,\u0026quot;U.1.2\u0026quot;,\u0026quot;W.1.2\u0026quot;,\u0026quot;3.1.2\u0026quot;,\u0026quot;%Y%5%7%6%5%Z%6%7%T.1.2\u0026quot;],\u0026quot;V\u0026quot;:R,\u0026quot;Q\u0026quot;:3,\u0026quot;S\u0026quot;:\u0026quot;/O/z/N/4/\u0026quot;,\u0026quot;M\u0026quot;:0,\u0026quot;L\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;K\u0026quot;:J,\u0026quot;I\u0026quot;:H,\u0026quot;G\u0026quot;:{\u0026quot;e\u0026quot;:F,\u0026quot;m\u0026quot;:\u0026quot;E\u0026quot;}}).i();',62,70,'D4KwDg5sDuCmBGZgCYCsxA03gBgIyD21YADgCFgBRdATlOQHYtLLgsAWZ9LANmducOGZMc/LAGZgYAE6wAkgDsAlgBdmOYDiYAzBQBtYAZwEBjOQEMAtrGCjULUZSzAjCgCbBECo8HMB7H3OAlAAsrJR9vK00dAE9gQG4DQGk5QEYdQHozQD10wA49QHvlQEYndzNLd1cBLGRgBXMIABFTJVMUR2QygE1UcwB9HyMANQBHABVUfU1iHAAvEF6ARU0AYRYp9U4cUWQHOm59HSXOQmQ1KVgANxk3GxZUSm45WAAPJVP3HS6Aa3ajL306pQBXQzGJsMjC9TJpzEolB0dCBkNswPo1PtgHoAppTDp9FYwLUgsBiGQUOJtIp9CE3Mg2ABlACyAAlyNxKAAxASs1lAA==='['\\x73\\x70\\x6c\\x69\\x63']('\\x7c'),0,{})) \u0026lt;/script\u0026gt;   看起来这也是一个函数啊，而且这个Base64的串似乎作为参数了，再次动用chrome的console帮助我们解析一下：\n这下我们大概可以明白几个事情：\n 这段代码实际上是 window[\u0026quot;eval\u0026quot;](...) 省略号部分是一个函数 function(p,a,c,k,e,d), 以 {} 包起来的是函数内容，那return p;} 后面的想必就是这6个参数。  观察一下这6个参数，我们会发现：\n p = 'X.B({\u0026quot;y\u0026quot;:8,\u0026quot;x\u0026quot;:\u0026quot;w v u t s r\u0026quot;,\u0026quot;q\u0026quot;:\u0026quot;8.1\u0026quot;,\u0026quot;p\u0026quot;:o,\u0026quot;n\u0026quot;:\u0026quot;4\u0026quot;,\u0026quot;l\u0026quot;:[\u0026quot;j.1.2\u0026quot;,\u0026quot;A.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;9-a.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;10.1.2\u0026quot;,\u0026quot;11.1.2\u0026quot;,\u0026quot;12.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;14.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;C.1.2\u0026quot;,\u0026quot;P.1.2\u0026quot;,\u0026quot;D.1.2\u0026quot;,\u0026quot;U.1.2\u0026quot;,\u0026quot;W.1.2\u0026quot;,\u0026quot;3.1.2\u0026quot;,\u0026quot;%Y%5%7%6%5%Z%6%7%T.1.2\u0026quot;],\u0026quot;V\u0026quot;:R,\u0026quot;Q\u0026quot;:3,\u0026quot;S\u0026quot;:\u0026quot;/O/z/N/4/\u0026quot;,\u0026quot;M\u0026quot;:0,\u0026quot;L\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;K\u0026quot;:J,\u0026quot;I\u0026quot;:H,\u0026quot;G\u0026quot;:{\u0026quot;e\u0026quot;:F,\u0026quot;m\u0026quot;:\u0026quot;E\u0026quot;}}).i();'\n  a = 62, c = 70\n  k = 'D4KwDg5sDuCmBGZgCYCsxA03gBgIyD21YADgCFgBRdATlOQHYtLLgsAWZ9LANmducOGZMc/LAGZgYAE6wAkgDsAlgBdmOYDiYAzBQBtYAZwEBjOQEMAtrGCjULUZSzAjCgCbBECo8HMB7H3OAlAAsrJR9vK00dAE9gQG4DQGk5QEYdQHozQD10wA49QHvlQEYndzNLd1cBLGRgBXMIABFTJVMUR2QygE1UcwB9HyMANQBHABVUfU1iHAAvEF6ARU0AYRYp9U4cUWQHOm59HSXOQmQ1KVgANxk3GxZUSm45WAAPJVP3HS6Aa3ajL306pQBXQzGJsMjC9TJpzEolB0dCBkNswPo1PtgHoAppTDp9FYwLUgsBiGQUOJtIp9CE3Mg2ABlACyAAlyNxKAAxASs1lAA==='['split']('|')\n  e = 0, d = {}\n 唯一需要处理的似乎就是k了，虽然k里没有|这个符号，不过刚才使用LZString.decompressfromBase64()函数解析出来的东西倒是有很多|。\n自此真相大白了，我们需要做的事情很简单：\n 提取出p,a,c,k,e,d这6个参数。 将k放进LZString.decompressfromBase64()解析一下。 调用 decode_func （也就是 function(p,a,c,k,e,d) ），得到结果。  结果长这样：\n我们要的图片链接就找到啦！在 files 里。\nStep 5: 我们还剩下最后一个问题：有了图片链接但是访问不了（403）怎么办？这似乎是一种简单的反爬虫方式，google一下，只要假装我们是从本站（即这个漫画的网站）进去的，而不是从其他地方进去的，就可以访问了。虽然在浏览器上做不到，但是python里可以通过更改Referer的方式来达到：\ndef get_download_header(): return {'User-Agent': random.choice(USER_AGENTS), \u0026quot;Referer\u0026quot;: \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot;}  Step 6: 最后的最后，就是爬虫的基本过程了，不过我们有一段javascript代码需要运行，怎么在python中运行javascript呢？\n 首先保存一下javascript代码，叫 decode_func.js。内容如下：  const jsdom = require(\u0026quot;jsdom\u0026quot;); const { JSDOM } = jsdom; const dom = new JSDOM(`\u0026lt;!DOCTYPE html\u0026gt;\u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt;`); window = dom.window; document = window.document; XMLHttpRequest = window.XMLHttpRequest; decode_func = window[\u0026quot;eval\u0026quot;](function(p,a,c,k,e,d){e=function(c){return(c\u0026lt;a?\u0026quot;\u0026quot;:e(parseInt(c/a)))+((c=c%a)\u0026gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;})  然后用以下这段代码就可以了：  def load_js(): with open(\u0026quot;decode_func.js\u0026quot;, 'r') as file: js = file.read() context = execjs.compile(js, cwd=\u0026quot;/usr/local/lib/node_modules\u0026quot;) return context context = load_js()  调用的时候就用 res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d)\n最终代码如下：\n参考代码 import requests from bs4 import BeautifulSoup import os import time import random import lzstring import execjs import re import json def create_dir(path): if not os.path.exists(path): os.makedirs(path) root_folder = '/Users/huzhenwei/Desktop/manga/' create_dir(root_folder) USER_AGENTS = [ \u0026quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\u0026quot;, \u0026quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\u0026quot;, \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\u0026quot;, \u0026quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\u0026quot;, ] def get_download_header(): return {'User-Agent': random.choice(USER_AGENTS), \u0026quot;Referer\u0026quot;: \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot;} def load_js(): with open(\u0026quot;decode_func.js\u0026quot;, 'r') as file: js = file.read() context = execjs.compile(js, cwd=\u0026quot;/usr/local/lib/node_modules\u0026quot;) return context context = load_js() def decode(s): x = lzstring.LZString() decoded_str = x.decompressFromBase64(s) return decoded_str.split(\u0026quot;|\u0026quot;) # p = \u0026quot;\u0026quot;\u0026quot;1h.14({\u0026quot;q\u0026quot;:7,\u0026quot;r\u0026quot;:\u0026quot;s t u v w x\u0026quot;,\u0026quot;y\u0026quot;:\u0026quot;7.1\u0026quot;,\u0026quot;A\u0026quot;:B,\u0026quot;C\u0026quot;:\u0026quot;6\u0026quot;,\u0026quot;D\u0026quot;:[\u0026quot;E.1.2\u0026quot;,\u0026quot;F.1.2\u0026quot;,\u0026quot;G.1.2\u0026quot;,\u0026quot;H.1.2\u0026quot;,\u0026quot;o.1.2\u0026quot;,\u0026quot;I.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;a.1.2\u0026quot;,\u0026quot;9.1.2\u0026quot;,\u0026quot;8.1.2\u0026quot;,\u0026quot;l.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;i.1.2\u0026quot;,\u0026quot;j.1.2\u0026quot;,\u0026quot;p.1.2\u0026quot;,\u0026quot;J.1.2\u0026quot;,\u0026quot;Y.1.2\u0026quot;,\u0026quot;L.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;K.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;18.1.2\u0026quot;,\u0026quot;1a.1.2\u0026quot;,\u0026quot;1g.1.2\u0026quot;,\u0026quot;1b.1.2\u0026quot;,\u0026quot;1c.1.2\u0026quot;,\u0026quot;1d.1.2\u0026quot;,\u0026quot;%1e%5%3%4%5%1f%4%3%12.1.2\u0026quot;],\u0026quot;19\u0026quot;:10,\u0026quot;Z\u0026quot;:11,\u0026quot;X\u0026quot;:\u0026quot;/W/z/V/6/\u0026quot;,\u0026quot;U\u0026quot;:0,\u0026quot;T\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;S\u0026quot;:R,\u0026quot;Q\u0026quot;:P,\u0026quot;O\u0026quot;:{\u0026quot;e\u0026quot;:N,\u0026quot;m\u0026quot;:\u0026quot;M\u0026quot;}}).n();\u0026quot;\u0026quot;\u0026quot; # a,c = 62,80 # k=['', 'jpg', 'webp', '9B', 'E5', '8B', '第02回', '27099', 'P0056', 'P0055', 'P0054', 'P0058', 'P0053', 'P0052', '', 'P0059', 'P0060', 'P0051', 'P0061', 'P0062', 'P0050', 'P0057', '', 'preInit', 'P0048', 'P0063', 'bid', 'bname', '总之就是非常可爱', 'fly', 'me', 'to', 'the', 'moon', 'bpic', '', 'cid', '354852', 'cname', 'files', 'P0044', 'P0045', 'P0046', 'P0047', 'P0049', 'P0064', 'P0068', 'P0066', 'GYeIdl7ujUrxJ1ls7JvwpQ', '1612951385', 'sl', '354596', 'prevId', '356912', 'nextId', 'block_cc', 'status', 'zzjsfckafmttm_lj2l', 'ps1', 'path', 'P0065', 'len', 'false', '35', 'BE', 'P0067', 'imgData', 'P0069', 'P0070', 'P0071', 'P0072', 'finished', 'P0073', 'P0075', 'P0076', 'P0077', 'E6', '9F', 'P0074', 'SMH'] # e = 0 # d = dict() # res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d) # print(type(res)) # print(res) # get content of one chapter def get_content(title, url): create_dir(os.path.join(root_folder, title)) res = requests.get(f\u0026quot;https://manhuagui.com{url}\u0026quot;, random.choice(USER_AGENTS)) # print(res.text) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all(lambda tag:tag.name=='script', recursive=True) for item in items: txt = item.string # 必须是item.string, 不能是item.txt if txt and \u0026quot;return p;\u0026quot; in txt: # 如果tag里没有文字，txt==None parts = txt.split(\u0026quot;return p;}(\u0026quot;) part = parts[1][:-2] split_res = re.split(r',([0-9]+,[0-9]+,)', part) p = split_res[0][1:-1] split_res[1] = split_res[1][:-1] a, c = map(int, split_res[1].split(',')) k = split_res[2].split(\u0026quot;'['\u0026quot;)[0][1:] k = decode(k) e = 0 d = dict() res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d) s = re.search('({.+})', res).group(0) # 找到一个由 {} 包裹的group info_dict = json.loads(s) files_list = info_dict[\u0026quot;files\u0026quot;] path_prefix = 'https://i.hamreus.com' + info_dict[\u0026quot;path\u0026quot;] i = 1 for file_name in files_list: complete_path = path_prefix + file_name[:-5] print(complete_path) res = requests.get(complete_path, headers=get_download_header()) img_name = os.path.join(root_folder, title, f'{i}.jpg') with open(img_name, 'wb') as file: file.write(res.content) file.flush() time.sleep(random.uniform(5.0, 10.0)) i += 1 # get manga url list def get_url_list(url): res = requests.get(url, random.choice(USER_AGENTS)) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('div', {\u0026quot;id\u0026quot;: \u0026quot;chapter-list-1\u0026quot;}) for manga_list in items: links = manga_list.find_all(\u0026quot;a\u0026quot;, recursive=True) links = links[1:] for link in links: title = link.get(\u0026quot;title\u0026quot;) ref = link.get(\u0026quot;href\u0026quot;) if title[-1] == '卷': continue print(f\u0026quot;{title}, {ref}\u0026quot;) get_content(title, ref) url = \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot; get_url_list(url)    注：上面这块代码被识别成lua语言了，样式出了点问题，可以在markdown里面指定语言，在第一个 ``` 后面加上语言名即可，如 ```python\n 后记 写这篇blog比玩爬虫本身还累啊，看来我果然不适合写作文（虽然我从小就深刻的明白这个道理）。不过这篇博客很大程度上也是写给自己看的，作为下次爬虫的参考（不知道下次爬虫要等到什么时候了）。\n以后可能会补点儿算法笔记，或者题解之类的。\n","date":"2021-02-01T22:45:03+08:00","permalink":"https://tom0727.github.io/post/002-%E7%88%AC%E8%99%AB/","tags":["爬虫","python"],"title":"初学爬虫小记"},{"categories":["工程"],"contents":"起因 在几天前折腾了爬虫，成功爬下来とにかくかわいい的漫画以后，我发现我折腾似乎上瘾了。聊天时无意提到”要是我有个人网站就好了“，于是就决定动手开始构建咕咕已久的个人网站。\n由于我对自己的前端水平十分有数，所以想都没想就立刻放弃了“要不自己写一个网站？”的想法。\n后来想起之前逛过的ouuan大佬的博客非常好看，我的收藏夹里甚至还有他搭建博客的指南，就直接拿来用了，采用的是 hugo + even主题 + github actions，参考资料如下:\n https://ouuan.gitee.io/post/from-hexo-to-hugo/\n 搭建过程 Step 1 首先阅读ouuan的指南(上述链接)，然后使用他的hugo模版，按照模版里指示的进行clone。\nStep 2 还是按照模版里指示的，修改一下配置文件config.toml里的相关配置，一些需要更改的内容：\n 包含yourname的部分 newContentEditor = \u0026quot;\u0026quot; defaultContentLanguage = \u0026quot;en\u0026quot; [[menu.main]]的相关内容 (视情况进行保留和删除) 不要更改 [params] 中的 version=\u0026quot;4.x\u0026quot;  Step 2.5 因为我打算部署到github pages上，就在github上创建一个新的repository，叫tom0727.github.io\nStep 3 配置完成后，可以 hugo new post/test.md 创建一个新的post(在hugo-blog/content/post/test.md), 按照markdown随便写点东西以后保存，然后 hugo server，打开localhost看一下效果(也可以边写边看效果，热加载真香)。最后用hugo命令生成静态文件，就是hugo-blog/public/文件夹，把这个文件夹内的内容push到github上就可以了。\n注： blog的源代码和网页内容并不是一个东西!\n 源代码: 是hugo-blog/ 下除了hugo-blog/public/以外的内容，包含了 content/, config.toml 之类的文件。 网页内容：只是 hugo-blog/public/内的内容，有了源代码就可以用hugo生成网页内容，但是反之就不可以！  既然两者有别，就要分开管理，我把它们放在同一个repository里，分成2个branch。源代码就放在了master里，网页内容就放在publish上了。\nStep 4 这个时候网页上应该是没有内容的，因为github pages需要设置一下指定deploy的branch，在repository的Settings里，拉到下面看到GitHub Pages，改一下Source branch就可以了：  需要在博文里插入图片的话，假设图片位于 static/images/001/1.png，就写上![image](/images/001/1.png)\n如果是插入link的话，就写 [link_name](https://...) 即可，外部链接记得加https://，不然会被当作本地的某个文件位置。\n 这些步骤做完就可以了，当然这种修改然后发布的方式太麻烦了，切branch也很累，所以就有了Step 5:\nStep 5: 我们配置一下Github actions，它能自动化部署流程。参考资料:\n https://segmentfault.com/a/1190000021815477\n 需要注意，因为源代码和网页内容在同一个repository里，就不用在github上折腾secret key之类的了，直接修改一下 hugo-blog/.github/workflows/deploy.yml (这个是template里自带的) 即可：\n personal_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: publish 将 depth 改成 fetch-depth (不然build的时候会报错)  这样就完成了，从此以后，写一篇新文章的步骤就变成：\n hugo new post/article.md 修改位于content/post/article.md的博客文章 add, commit, 把源代码push到master  这样就可以了，不必切branch然后push网页内容了。\n push到master以后，可以在repository的Actions页面查看一下deploy的情况：  Step 6: 因为github.io似乎被墙了，所以学ouuan弄了一个gitee镜像，教程的话参照这两个就可以了：\n https://jasonkayzk.github.io/2020/09/18/%E5%9C%A8Gitee%E6%90%AD%E5%BB%BAGithub-Pages/\n  https://github.com/yanglbme/gitee-pages-action\n gitee镜像的访问网址：tom0727.gitee.io\n注：在 hugo-blog/.github/workflows/sync.yml里记得设置一下on，不然触发不了自动部署。\n我这里设置的是：\non: push: branches: - master workflow_dispatch:  Step 7: 评论区用很多种，我选用了utterances，部署步骤如下：\n 在Github上安装 utterances app，选择这个博客的repo 在 config.toml 中更改配置，将 [params.utterances] 下的 repo 改成这个repo的名字即可。（可以新开一个repo来储存评论，不过评论会以issues的形式出现在repo里，所以没必要新开一个）  TODO LIST  搞明白baidu push是什么  结语 新的一轮折腾结束了，总体来说还是比较满意这个博客的，个人很喜欢这种极简风的博客，功能也比较全，某种意义上算是告别了在Microsoft Word里做笔记的生活（？），之后打算先补上爬虫的一些笔记，还有搬运一点Word上的笔记吧。\n","date":"2021-02-01T21:21:41+08:00","permalink":"https://tom0727.github.io/post/001-hugo-tutorial/","tags":["hugo","博客"],"title":"Hugo博客搭建小记"},{"categories":null,"contents":"Hello, this is Tom from China! If you have trouble visiting this site (especially for mainland China users), please try visit\nhttps://tom0727.gitee.io/\nAbout me  Year 3 Undergraduate student @ HKU (The University of Hong Kong), 2018-2022 Major in Computer Science Competitive programming as hobby   Resume  Resume (in English): https://github.com/tom0727/Resume/blob/master/Zhenwei%20Hu.pdf Resume (in Chinese): https://github.com/tom0727/Resume/blob/master/%E8%83%A1%E6%8C%AF%E4%B8%BA.pdf  Contact  Email: huzhenweitom@gmail.com QQ/Wechat: 980409152  Links  Codeforces:  Leetcode: tom0727  ","date":"2021-01-31T22:57:58+08:00","permalink":"https://tom0727.github.io/about/","tags":null,"title":"About"},{"categories":null,"contents":"","date":"2020-02-07T17:43:21+08:00","permalink":"https://tom0727.github.io/search/","tags":null,"title":"搜索"}]