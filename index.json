[{"categories":["题解"],"contents":"题目链接 https://www.luogu.com.cn/problem/P1450\n题意\n有 $n$ 种烹饪方法，$m$ 种主要食材。每道菜都只用 恰好一种 烹饪方法和主要食材，同时对于 每种烹饪方法 $i$ 和 主要食材 $j$，有 $a_{ij}$ 种不同的菜。所以总共有 $\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^m a_{ij}$ 道不同的菜。\n现在需要求做菜方案 （设总共有 $k$ 道菜，$k$ 可以取任何数），满足：\n $k \\geq 1$ 每道菜的烹饪方法 $i$ 各不相同 每种主要食材 $j$ 最多在一半（$\\lfloor \\frac{k}{2} \\rfloor$）的菜中出现  求满足上述条件的做菜方案个数？\n$1 \\leq n \\leq 100, 1 \\leq m \\leq 2000, 0 \\leq a_{ij} \u0026lt; 998244353$\n 题解 首先考虑条件1和2，满足这些条件的总方案数有 $((s_1+1) * (s_2+1) * (s_3+1) * \u0026hellip; * (s_n+1) - 1)$ 种，其中 $s_i = \\sum\\limits_{j=1}^m a_{ij}$\n（因为对于每种烹饪方法 $i$，还可以 不选，所以是 $(s_i+1)$，最后减去 全部不选 的情况）\n这样，我们减去 不满足条件3 的方案数即可！\n我们枚举超过限制的主要食材 $j$，然后设 $dp[i][k]$ 为：当前到了第 $i$ 种烹饪方法，使用了 $k$ 种主要食材 $j$ 的方案数。\n那么问题关键在于，对于某一种烹饪方法 $i$，我们可以不选任何菜，这怎么办？\n我们假设有 $t$ 个不选的，那么总共就选了 $n-t$ 个菜，要保证 $k \u0026gt; \\lfloor \\frac{n-t}{2} \\rfloor$，即 $2k + t \u0026gt; n$。\n所以，我们可以改变一下状态的定义，我们可以将 不选 变成 选了一种主要食材 $j$，而 选择主要食材 $j$ 就变成 选择了两个主要食材 $j$。这样，只要满足 不选的数量 + 2 * 选择主要食材 \u0026gt; n，就不满足条件3了！\n转移方程就很好写了，对于每一种烹饪方法 $i$，有 $3$ 种决策方案：\n 选择主要食材 $j$：dp[i][k] += dp[i-1][k-2] * a[i][j]; 不选任何菜： dp[i][k] += dp[i-1][k-1]; 选择非主要食材：dp[i][k] += (dp[i-1][k] * (sum[i] - a[i][j]));   注意，不能将 dp 数组变成一维然后倒序转移！\n比如，在第三种转移时，(sum[i] - a[i][j]) == 0，那么如果是二维的，此时 dp[i][k] = 0，而如果是一维的，就会变成 dp[i][k] = dp[i-1][k]。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 998244353; const int maxn = 1e5+5; ll dp[103][205]; ll sum[105]; ll a[103][2003]; int n,m; int main() { fastio; ll ans = 1; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j]; sum[i] = (sum[i] + a[i][j]) % mod; } ans = (ans * (sum[i]+1LL)) % mod; } ll delta = 1LL; for (int j = 1; j \u0026lt;= m; j++) { memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int k = 0; k \u0026lt;= 2*n; k++) { dp[i][k] = (dp[i][k] + dp[i-1][k] * (sum[i] - a[i][j]) % mod) % mod; if (k \u0026gt;= 1) { (dp[i][k] += dp[i-1][k-1]) %= mod; } if (k \u0026gt;= 2) { dp[i][k] = (dp[i][k] + dp[i-1][k-2] * a[i][j] % mod) % mod; } } } for (int k = n+1; k \u0026lt;= 2*n; k++) (delta += dp[n][k]) %= mod; } ans -= delta; (ans %= mod) += mod; ans %= mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  ","date":"2021-03-05T14:58:19+08:00","permalink":"https://tom0727.github.io/post/019-luogu-p5664/","tags":["数学","计数","dp"],"title":"Luogu P5664 Emiya家今天的饭（计数，dp）"},{"categories":["题解"],"contents":"题目链接 https://www.luogu.com.cn/problem/P1450\n题意\n共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$\n某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚的 第 $i$ 种硬币，想购买价值为 $s$ 东西（不设找零）。请问每次有多少种付款方法。\n其中，$1 \\leq c_i,d_i,s \\leq 10^5, 1 \\leq n \\leq 1000$\n 题解 先考虑每个硬币有 无限 个的情况。\n设 $dp[i][j]$ 为：使用 前 $i$ 种硬币，购买 价值为 $j$ 的物品的方案数，那么有：\n$dp[i][j] = \\sum\\limits_{k=1}dp[i-1][j-c_i*k]$。\n很明显，这是一个 无穷背包，所以可以直接优化为：\ndp[0] = 1; for (int i = 1; i \u0026lt;= 4; i++) { for (int j = 1; j \u0026lt;= 1e5; j++) { if (j - c[i] \u0026gt;= 0) dp[j] += dp[j-c[i]]; } }  那么，现在考虑 只有一种硬币有限制 的情况：\n由于 $dp[j]$ 都是从 $dp[j-c_i]$ （实际上就是从 $dp[j-k*c_i]$）转移过来的，那么我们只要把 硬币超出限制的转移情况 删掉即可！\n所以，$dp[j] - dp[(d_i+1) * c_i]$ 就是答案了！\n那么如果 多个硬币有限制 呢？考虑 容斥 ！\n假设有 $3$ 种硬币，那我们就 减去 $1$ 种硬币超限的情况，加上 $2$ 种硬币超限的情况，减去 $3$ 种硬币超限的情况。\n枚举这些情况，使用 bitmask 即可！(具体的见代码)\n 容斥中，每一项的符号根据 bitmask 中 bit 的个数来决定！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e5+5; ll dp[maxn]; int arr[5]; int d[5]; int q,s; int main() { for (int i = 1; i \u0026lt;= 4; i++) cin \u0026gt;\u0026gt; arr[i]; cin \u0026gt;\u0026gt; q; dp[0] = 1; for (int i = 1; i \u0026lt;= 4; i++) { for (int j = 1; j \u0026lt;= 1e5; j++) { if (j - arr[i] \u0026gt;= 0) dp[j] += dp[j-arr[i]]; } } while (q--) { for (int i = 1; i \u0026lt;= 4; i++) cin \u0026gt;\u0026gt; d[i]; cin \u0026gt;\u0026gt; s; ll ans = dp[s]; for (int mask = 1; mask \u0026lt;= (1\u0026lt;\u0026lt;4)-1; mask++) { // 枚举容斥 int cnt = 0; int cur = 0; for (int j = 1; j \u0026lt;= 4; j++) { if (mask \u0026amp; (1\u0026lt;\u0026lt;(j-1))) { cur += ((d[j]+1) * arr[j]); cnt++; // 判断加号还是减号 } } if (s \u0026gt;= cur) { if (cnt \u0026amp; 1) ans -= dp[s - cur]; else ans += dp[s - cur]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   其他例题(TODO) ","date":"2021-03-04T23:29:54+08:00","permalink":"https://tom0727.github.io/post/018-luogu-p1450/","tags":["数学","计数","容斥"],"title":"Luogu P1450 硬币购物（计数，容斥）"},{"categories":["算法"],"contents":"记录一些组合数学的公式。\n公式 组合数 $C(n,m)$  $C_n^0 = C_n^n = 1$ $C_n^k = C_{n-1}^k + C_{n-1}^{k-1}$ $C_n^k = \\frac{n!}{k!(n-k)!}$   注：$0! = 1, (0!)^{-1} = 1$\n 证明公式2 $n$ 个中选 $k$ 个， 考虑 $n$ 个元素中的第一个元素：\n 如果它被选中，有 $C_{n-1}^{k-1}$ 种。 如果它没有被选中，有 $C_{n-1}^k$ 种。    二项式定理 $(a+b)^n = \\sum\\limits_{k=0}^n C_n^ka^kb^{n-k}$\n 卡特兰数 (Catalan) 通项公式：\n $H_n = 1 ~ (n=0,1)$\n  $H_n = \\frac{C_{2n}^n}{n+1}~(n \\geq 2)$\n  $H_n = C_{2n}^n - C_{2n}^{n-1}$\n  递推式：\n  $H_n = \\sum\\limits_{i=0}^{n-1}H_{i}H_{n-i-1} = H_0H_{n-1} + H_1H_{n-2} + \u0026hellip; + H_{n-1}H_0$\n  $H_n = \\frac{(4n-2)}{n+1} H_{n-1}$\n   第二类斯特林数 $S(n,m)$ 代表将 $n$ 个不同的小球，放进 $m$ 个相同，非空盒子的方案数\n通项公式：\n$S(n,m) = \\sum\\limits_{i=0}^m (-1)^{m-i}\\frac{i^n}{i!(m-i)!}$\n递推式：\n$S(n,m) = m*S(n-1,m) + S(n-1,m-1)$\n证明 考虑第一个小球，有两种情况：\n 独占一个盒子：相当于，其他 $n-1$ 个小球要放进 $m-1$ 个盒子中，且盒子不为空，所以为 $S(n-1,m-1)$ 不独占一个盒子：相当于，先将其他 $n-1$ 个小球放进 $m$ 个盒子中，且盒子不为空，然后从 $m$ 个盒子中选一个，把当前小球放进去，所以为 $m*S(n-1,m)$   经典例题 例1 男女生排列问题 题意\n三个女生和五个男生站成一排。\n  如果女生必须全排在一起，有多少种排法？\n  如果女生不能相邻，有多少种排法？\n  如果两端都不排女生，有多少种排法？\n  如果两端不都排女生，有多少种排法？\n   第一题答案 将3个女生看作1个，所以就有 $A_6^6$ 种。对于女生内部的排列有 $A_3^3$ 种。所以总共为 $A_6^6A_3^3$ 种。\n 第二题答案 先排男生，有 $A_5^5$ 种，然后将女生插入6个空位中，有 $A_6^3$ 种。所以总共为 $A_5^5A_6^3$ 种。\n 第三题答案 先排好两个男生在两边，有 $A_5^2$ 种，两个男生中间的人就可以随便排了，就有 $A_6^6$ 种。所以总共为 $A_5^2A_6^6$ 种。\n也可以这么想，让女生在中间的6个位置先选好3个，有 $A_6^3$ 种，剩下的男生随便排，有 $A_5^5$ 种。所以总共为 $A_6^3A_5^5$ 种，答案和上面一样。\n 第四题答案 所有排列情况有 $A_8^8$ 种，如果两边都排女生，有 $A_3^2A_6^6$ 种。所以总共为 $A_8^8 - A_3^2A_6^6$ 种。\n  例2 小球放盒子问题 假设有 $n$ 个小球，$m$ 个盒子。\n小球无区别-盒子无区别-不允许空盒 略（还没遇到）\n 小球无区别-盒子无区别-允许空盒 略（还没遇到）\n 小球无区别-盒子有区别-不允许空盒 使用隔板法，在 $n$ 个小球中间放置 $m-1$ 块挡板，将小球分为不为空的 $m$ 部分。小球之间的空位有 $n-1$ 个。所以答案为\n$C_{n-1}^{m-1}$\n 小球无区别-盒子有区别-允许空盒 先多加 $m$ 个小球，转化为 不允许空盒 的问题后，再把多加的 $m$ 个小球拿出来即可。所以答案为\n$C_{n+m-1}^{m-1}$\n 小球有区别-盒子无区别-不允许空盒 答案就是第二类斯特林数 $S(n,m)$，递推式如上：\n$S(n,m) = m*S(n-1,m) + S(n-1,m-1)$\n 小球有区别-盒子无区别-允许空盒 在 不允许空盒 的基础上，枚举一下 空盒的个数。所以答案为\n$\\sum\\limits_{i=1}^{\\min(n,m)}S(n,i)$\n 小球有区别-盒子有区别-不允许空盒 在 盒子无区别 的基础上，乘上盒子的排列 $m!$ 即可，所以答案为：\n$S(n,m) * m!$\n 小球有区别-盒子有区别-允许空盒 每个小球可以随便选，互不影响，所以答案为：\n$n^m$\n  例3 错排问题 题意\n有 $1,2,3,\u0026hellip;,n$ 这些数字，重新排序使得不存在任何一个数字的位置和原来相同，有多少种方法？\n 答案 $D_n = (n-1)(D_{n-1} + D_{n-2})$，其中 $D_1 = 0, D_2 = 1$\n证明：初始情况下如图：\n在图中，上下两行对应的元素需要错开。我们设这种情况下，排序的方法有 $f(n)$ 种。\n对于元素 $1$，我们可以选择除 $1$ 以外的任何一个元素，所以有 $n-1$ 种。\n假设我们选了 $1 \\rightarrow 2$，就会变成下图：\n那么，再看元素 $2$：\n  如果 $2 \\rightarrow 1$，那么就会变成下图，即 $f(n-2)$ 种。   如果 $2 \\rightarrow 3 ~ or ~ 4 ~ or ~ \u0026hellip; ~ n$，就相当于 $2$ 和 $1$ 必须错开，那就相当于下图，即 $f(n-1)$ 种。\n  所以最终就可以得到 $f(n) = (n-1)(f(n-1) + f(n-2))$\n","date":"2021-03-02T18:35:43+08:00","permalink":"https://tom0727.github.io/post/017-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","tags":["数学"],"title":"组合数学"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_f\n题意\n初始时有个函数 $f(x) = 0$，现在有 $Q$ 个询问，询问有两种：\n1 a b：令 $f(x) = f(x) + |x-a| + b$\n2：求 $x$ 使得 $f(x)$ 最小，并求出这个 $f(x)$ 的最小值\n 题解 $f(x)$ 必然长这样：$f(x) = |x-a_1| + |x-a_2| + \u0026hellip; + |x-a_n| + \\sum\\limits_{i=1}^{n}b_i$\n要让 $f(x)$ 最小，就令 $x$ 等于 $a_1,a_2,\u0026hellip;,a_n$ 的中位数。\n那么已知中位数 $a_k$ 的话，如何找到 $\\sum\\limits_{i=1}^{n} |a_k - a_i|$ ？\n假设 $n$ 为奇数，那如果我们将 $a_i$ sort 一下，有：\n$\\sum\\limits_{i=1}^{n} |a_{\\frac{n+1}{2}} - a_i| = \\sum\\limits_{i=1}^{\\frac{n}{2}}(a_{\\frac{n+1}{2}+i} - a_{\\frac{n+1}{2}-i})$\n如果我们分开维护中位数 $a_{\\frac{n+1}{2}}$ 左右两边的 sum 就可以 $O(1)$ 求和了！\n 用对顶堆！\n我们维护两个 multiset\u0026lt;ll\u0026gt;，一个是大顶堆（叫做small），维护小于等于中位数的部分。一个是小顶堆（叫做big），小顶堆维护大于等于中位数的部分，并且保证两者的 size 之差 $\\leq 1$。\n 插入新值的时候，就和当前中位数比较一下，如果小于等于中位数就插入small，否则插入big，然后看一下size之差，如果 size之差 $\u0026gt; 1$ 就从多的那个堆取出来，插入另外一个堆，这样就动态调整了中位数。\n 这样我们可以 $O(1)$ 求出中位数，并且 $\\sum\\limits_{i=1}^{n} |a_k - a_i|$ 也可以 $O(1)$ 得出，用big的$sum$ 减去 small的 $sum$ 即可。（写的时候需要讨论一下 size 之差为 1,0,-1 的三种情况）。\n细节部分直接看代码吧。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e3+5; const int maxm = 2e5+10; ll c = 0, ssum = 0, bsum = 0; multiset\u0026lt;ll\u0026gt; big; multiset\u0026lt;ll, greater\u0026lt;ll\u0026gt; \u0026gt; small; void ins(ll a, ll b) { c += b; if (!small.size()) { ssum += a; small.insert(a); return; } if (a \u0026lt;= *small.begin()) { small.insert(a); ssum += a; } else { big.insert(a); bsum += a; } if (small.size() \u0026gt; big.size() + 1) { auto p = small.begin(); bsum += *p, ssum -= *p; big.insert(*p); small.erase(p); } if (big.size() \u0026gt; small.size() + 1) { auto p = big.begin(); bsumssum += *p; small.insert(*p); big.erase(p); } } void query() { ll ans = bsum if (small.size() == big.size()) { cout \u0026lt;\u0026lt; *small.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return; } if (small.size() == big.size() + 1) { ans += *small.begin(); cout \u0026lt;\u0026lt; *small.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return; } if (big.size() == small.size() + 1) { ans -= *big.begin(); cout \u0026lt;\u0026lt; *big.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } int main() { fastio; int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ins(a,b); } else { query(); } } }   其他例题(TODO)  https://www.luogu.com.cn/problem/P3644  ","date":"2021-03-01T21:35:11+08:00","permalink":"https://tom0727.github.io/post/016-at-abc127f/","tags":["数据结构","堆"],"title":"Atcoder ABC 127F（对顶堆动态维护中位数）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_e\n题意\n给定一个矩阵，包含 $N \\times M$ 个格子，现在从中选出 $K \\leq N \\times M$ 个不同的格子，记为 $(x_1,y_1), (x_2, y_2), \u0026hellip; , (x_K, y_K)$ ，记\n$cost = \\sum\\limits_{i=1}^{K-1}\\sum\\limits_{j=i+1}^{K}(|x_i-x_j| + |y_i-y_j|)$\n求：对于所有不同的 $K$ 个格子的选法，$cost$ 的sum为多少？\n 法一概率 选 $k$ 个格子的方案数为 $C(n+m, k)$，在 $k$ 个格子中，任选 $2$ 个出来，有 $C(k,2)$ 种，考虑它们的贡献：\n因为是全部方案，所以可以考虑用 期望值 来做！\n问题转化为，从 $N \\times M$ 的矩阵中，选择 $2$ 个不同的点 $(x_i, y_i), (x_j,y_j)$ ，求 $|x_i - x_j| + |y_i-y_j|$ 的期望？\n期望为： $\\frac{n+m}{3}$\n 如果推式子很难，这里是一些小技巧（仅用于 分母中无 $n,m$ ，并且分子中不存在 $nm$ 之类的项）：\n 打表找规律：假设期望值 $E(n,m)$ 是一个关于 $n,m$ 的多项式，那么固定一下 $n$ 的值，然后让 $m = 1,2,3\u0026hellip;$ 来打表找出 $E(n,m)$ 和 $m$ 的关系。同理可以找出 $E(n,m)$ 和 $n$ 的关系，相加一下就可以了。\n  拉格朗日插值法：设 $ans = F(n,m) = E(n,m) * C(nm, 2)$，我们可以固定 $n$，然后用插值法找出 $F(n,m)$ 和 $m$ 的关系。（这个函数有两个变量，按理说应该是固定每一个 $n$ 然后对每一个 $n$ 都进行一次插值法的，以后遇到了可以尝试一下。）\n  严谨证明：\n考虑一个点 $(x,y)$，那么\n纵向贡献 为： $v_{x,y} = [(1+2+\u0026hellip;+x-1) + (1+2+\u0026hellip;+n-x)] * m$\n横向贡献 为： $h_{x,y} = [(1+2+\u0026hellip;y-1) + (1+2+\u0026hellip;+m-y)] * n$\n期望就是 $E(n,m) = \\frac{\\sum\\limits_{x=1}^n \\sum\\limits_{y=1}^m (v_{x,y} + h_{x,y})}{C(nm,2)} = \\frac{n+m}{3}$\n 以上，最终的答案就是\n$ans = C(nm,k) * C(k,2) * \\frac{n+m}{3}$\n 法二计数 我们选择 $2$ 个格子，有 $C(nm-2, k-2)$ 种。\n对于横坐标的差值为 $d_x$ 的情况，有 $(n-d_x) m^2$ 种。贡献就是 $(n-d_x)m^2*d_x$\n对于纵坐标的差值为 $d_y$ 的情况，有 $(m-d_y) n^2$ 种。贡献就是 $(m-d_y) n^2*d_y$\n所以答案就是\n$ans = C(nm-2, k-2) (\\sum\\limits_{d_x=1}^{n-1} (n-d_x)m^2*d_x + \\sum\\limits_{d_y=1}^{m-1} (m-d_y)n^2*d_y)$\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 2e5+5; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; (a *= a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } ll inv(ll a) { return qpow(a, mod-2); } ll n,m,k; ll fac[maxn]; void init() { fac[0] = 1; fac[1] = 1; for (int i = 2; i \u0026lt;= n*m; i++) { fac[i] = (fac[i-1] * (ll)(i)) % mod; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; init(); ll nu = fac[n*m] * k % mod * (k-1) % mod * (n+m) % mod; ll de = inv(fac[k]) * inv(fac[n*m-k]) % mod * inv(6) % mod; cout \u0026lt;\u0026lt; (nu * de) % mod \u0026lt;\u0026lt; endl; }   参考链接  https://blog.csdn.net/weixin_30323631/article/details/96351727 https://blog.csdn.net/qq_40655981/article/details/90642350  一些数学知识 Q1. 如果不限定坐标为整数，长度为 $n$ 的线段上任取两个点，距离期望值是？\nA1. 答案为 $\\frac{n}{3}$，有两种方法。\n第一种：先假设坐标只能为 $1,2,\u0026hellip;,n$ 的整数，那么求出的期望是 $E_n = 2\\times \\frac{\\sum\\limits_{i=1}^{n}i(n-i)}{n^2} = \\frac{n^2-1}{3n}$，取一个 $n$ 趋向无穷，就有 $E = \\lim_{n \\to \\infty} \\frac{n^2-1}{3n} = \\frac{n}{3}$\n 上述推导需要用到 $1^2 + 2^2 + \u0026hellip; + n^2 = \\frac{1}{6}n(n+1)(2n+1)$\n 第二种：先假设线段长度为 $1$，则有期望为 $\\frac{\\int_{0}^1 \\int_{0}^1 |x-y| ~dydx}{\\int_{0}^1 \\int_{0}^1 1~ dydx} = \\int_{0}^1 \\int_{0}^x (x-y) ~ dydx + \\int_{0}^1 \\int_{x}^1 (y-x) ~dydx = \\frac{1}{3}$，对于线段长度为 $n$，乘上 $n$ 即可。（记得分母要除以样本空间，即 $\\int_{0}^1 \\int_{0}^1 1~ dydx$）\n Q2. 如果不限定坐标为整数，$n \\times n$ 的正方形中任取两个点，距离期望值是？\nA2. 答案约为 $0.521$，具体分析可以见 这里 和 这里\n其他例题(TODO)  https://www.luogu.com.cn/problem/P4781  ","date":"2021-02-28T23:20:51+08:00","permalink":"https://tom0727.github.io/post/015-at-abc127e/","tags":["数学","计数","概率"],"title":"Atcoder ABC 127E（数学，计数，概率）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc162/tasks/abc162_e\n题意\n给定 $2 \\leq N \\leq 10^5, 2 \\leq K \\leq 10^5$，现有长度为 $N$ 的序列 $\\{ a_1, a_2, \u0026hellip;, a_N \\}$，其中 $1 \\leq a_i \\leq K$\n这样的序列总共有 $K^N$ 个，求所有这些序列的 $\\sum \\gcd(a_1,a_2,\u0026hellip;,a_N)$？\n 题解 发现我们可以根据 $\\gcd$ 的值进行枚举，我们设 $\\gcd(a_1,a_2,\u0026hellip;,a_N) = x$ 的序列数量为 $d_x$，则有：\n$d_1 = K^N - d_2 - d_3 - \u0026hellip; - d_k$\n那么 $d_2$ 呢？我们发现如果 $\\gcd(a_1,a_2,\u0026hellip;,a_N) = 2$，则所有的 $a_i$ 必然为 2的倍数，所以每个位置上有 $\\frac{K}{2}$ 种选法，即：\n$d_2 = (\\frac{K}{2})^N - d_4 - d_6 - \u0026hellip; - d_{\\frac{K}{2} \\times 2}$\n同理有：\n$d_3 = (\\frac{K}{3})^N - d_6 - d_9 - \u0026hellip; - d_{\\frac{K}{3} \\times 3}$\n\u0026hellip;\n$d_K = 1$\n这样，直接用一个 dp[] 记录一下 $d_x$ 的值，然后倒着枚举，暴力计算即可。\n最终的答案为 $\\sum\\limits_{i=1}^K i \\times dp[i]$\n时间复杂度：$T(K) = K + \\frac{K}{2} + \\frac{K}{3} + \u0026hellip; + \\frac{K}{K} = K(1+\\frac{1}{2}+\\frac{1}{3}+\u0026hellip;+\\frac{1}{K})$\n发现这个是 harmonic series 的和，复杂度大概为： $1+\\frac{1}{2}+\\frac{1}{3}+\u0026hellip;+\\frac{1}{K} = O(\\log k)$\n所以最终时间复杂度是 $O(K\\log K)$\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 1e5+5; int n,k; ll dp[maxn], ans = 0; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; b \u0026gt;\u0026gt;= 1; (a *= a) %= mod; } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = k; i \u0026gt;= 1; i--) { ll d = 0; for (int j = 2; i * j \u0026lt;= k; j++) { d += dp[i*j]; } d %= mod; ll r = qpow(k/i, n); dp[i] = (r-d+(ll)mod) % mod; ans = (ans + (ll)(i) * (ll)(dp[i])) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   一些拓展 在洛谷上看题解的时候，看到了莫比乌斯反演的方法，如果未来学了的话可以重新来做一下，loj上有加强版的题目 ($K \\leq 10^{11}$)\n其他例题(TODO)  https://loj.ac/p/6491 (需要莫比乌斯反演)  ","date":"2021-02-27T14:59:58+08:00","permalink":"https://tom0727.github.io/post/014-at-abc162e/","tags":["数学","计数"],"title":"Atcoder ABC 162E（数学，计数）"},{"categories":["算法"],"contents":"定义 最小环：指图中的一个环，它不包含任何更小的环。\n在无向图中，最小的最小环为3个节点。在有向图中，最小的最小环为2个节点。（不考虑self-loop的情况）\n无权无向图求最小环 例题: https://codeforces.com/contest/1364/problem/D\n题意\n给定一个 connected undirected graph:\n$n$个vertex, 和一个int $k$, 其中 $3 \\leq k \\leq n$, 请找出 以下的其中之一:\n  一个独立集(set of vertex， 两两之间没有edge)， 包含 $\\lceil\\frac{k}{2}\\rceil$ 个vertex\n  一个simple cycle (set of vertex, 不包含重复vertex)， 其中 $len \\leq k$\n   题解   如果这是一个tree ($m = n-1$), 则 (1)很容易找, 只要dfs一下，做一个图的染色 (染成 $0,1$)即可, 最后取 全部的 $0$ 或者 全部的 $1$\n  如果不是tree, 必然存在cycle, 那么我们可以找到一个最小环, 最小环必然满足 (1) 或者 (2)！（易证）\n  •怎么找最小环? 用DFS!\n 维护一个环的长度 len 维护一个 dep[] 数组, 代表每个vertex的depth 维护一个 pre[] 数组, pre[u] 代表dfs过程中 u的parent 维护一个 int c, 代表找到的cycle的 终点!  然后，\n  从vertex 1开始dfs， dep[to] = dep[cur] + 1 这样来更新 dep[]\n  当我们找到一个backward edge时, 更新最小环长度\nlen = min(len, abs(dep[to] - dep[cur]) + 1))  并且更新c, 使得 c = cur, 然后继续探索！\n  dfs结束后, 直接用\nvector\u0026lt;int\u0026gt; cycle; void findcycle() { while (len--) cycle.push_back(c), c = pre[c]; }  即可找到最小环！\n  时间复杂度：$O(n+m)$\n 无权有向图求最小环 例题：https://atcoder.jp/contests/abc142/tasks/abc142_f\n题意\n给定一个 directed graph，求它的一个 subgraph 满足：\n $V'$ 是 $V$ 的 non-empty subset $E'$ 是 $E$ 中，所有两端均在 $V'$ 内的edges $V'$ 中，所有的 vertex 的 in-degree 和 out-degree 均为1   题解 易知，最小环满足这个条件！\n如何求最小环？可以用 $N$ 次 DFS！\n 维护 ed 代表环的终点，维护最小环长度 final 维护一个 dep[] 数组, 代表每个vertex的depth 维护一个 par[] 数组, par[u] 代表dfs过程中 u的parent 维护一个 in[] 数组，代表在dfs过程中，当前的某个vertex是否存在于递归stack中！  dfs过程如下：\nint n,m, dep[maxn], par[maxn]; int ans = 1e9, ed = -1, final = 1e8; vector\u0026lt;int\u0026gt; cycle; bool in[maxn]; void dfs(int cur) { in[cur] = 1; dep[cur] = dep[par[cur]] + 1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (dep[to]) { if (in[to]) { // 必须得在递归栈内 int res = abs(dep[cur] - dep[to]) + 1; if (res \u0026lt; ans) { ans = res; ed = cur; } } } else { par[to] = cur; dfs(to); } } in[cur] = 0; }   为什么要加 in[] 数组？\n 如下图：\n我们需要保证这个环必然全部同时出现在递归stack内，否则可能会出问题！\n（如上图，如果不考虑 in[] 数组的话，就有可能错误的把 1-\u0026gt;3-\u0026gt;2 当作一个环！\n 为什么要使用 $N$ 次 dfs ？\n 如下图：\n如果我们从 $1$ 开始进行 dfs，那么如果是按照图上的访问顺序，会导致我们找不到最小环！\n但是如果从 $7$ 开始进行 dfs，就可以找到了！\n所以我们需要每一个点都开始一次dfs，总共 $N$ 次 dfs。\n 注：优化：可以在每次dfs中找到的环中找最小环，如果不是环中的节点，就不需要考虑了。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define abs(a) ((a\u0026gt;0)?a:-(a)) const int mod = 1e9+7; const int maxn = 1e3+5; const int maxm = 2e3+10; struct Edge { int to,nxt; } edges[maxm]; int head[maxn], ecnt = 1; int n,m, dep[maxn], par[maxn]; int ans = 1e9, ed = -1, final = 1e8; vector\u0026lt;int\u0026gt; cycle; bool in[maxn]; void add(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); } } void dfs(int cur) { in[cur] = 1; dep[cur] = dep[par[cur]] + 1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (dep[to]) { if (in[to]) { int res = abs(dep[cur] - dep[to]) + 1; if (res \u0026lt; ans) { ans = res; ed = cur; } } } else { par[to] = cur; dfs(to); } } in[cur] = 0; } void renew() { fill(dep, dep+n+1, 0); fill(par, par+n+1, 0); fill(in, in+n+1, 0); ans = 1e9; } int main() { fastio; init(); for (int i = 1; i \u0026lt;= n; i++) { dfs(i); if (ans \u0026lt; final) { final = ans; cycle.clear(); while (ans--) cycle.push_back(ed), ed = par[ed]; } renew(); } if (final == 1e8) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else { cout \u0026lt;\u0026lt; final \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int a : cycle) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   有权图求最小环 Floyd $O(n^3)$ 可求！\n","date":"2021-02-25T23:41:02+08:00","permalink":"https://tom0727.github.io/post/013-%E6%9C%80%E5%B0%8F%E7%8E%AF/","tags":["图论","最小环","dfs"],"title":"最小环"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1492/problem/E\n题意\n给定一个 directed and weighted graph，$2 \\leq n \\leq 2\\cdot10^5, 2 \\leq m \\leq \\min(2\\cdot10^5, n(n-1))$，每个vertex的 out-degree 最多为 $1\\leq k \\leq 9$，每个edge的weight均不相同。\n现在定义一个tuple $(c_1,c_2,\u0026hellip;,c_k)$，其中， $\\forall j \\in [1,k]$，有 $1\\leq c_j \\leq j$。\n且对于所有 out-degree 等于 $j$ 的vertex，只保留它的out-going edges中，weight第 $c_j$ 小的那个edge。\n 例如，对于vertex 5，有 $3$ 条out-going edges (以(u,v,w)的形式)： $(5,2,233), (5,4,25), (5,6,999)$\n如果 $c_3 = 1$，因为 vertex 5 具有 out-degree = $3$，所以 $c_3$ 生效，因为 $c_3 = 1$，所以保留第 $1$ 小的edge，也就是$(5,4,25)$。\n 现在求 $(c_1,c_2,\u0026hellip;,c_k)$ 的数量，使得整个图是强连通的。\n 题解 首先可以发现，因为每个edge的weight都不同，所以对于每一个vertex来说，必然只能保留最多 $1$ 个out-going edge。所以整个图中，只有 $n$ 个edge。\n又因为需要强连通，所以它只有可能是 一个环！所以只要看 每个vertex的 in-degree 是否都等于$1$即可！\n再转化一下，我们只要看在 $(c_1,c_2,\u0026hellip;,c_k)$ 的情况下，所有out-going edge所指向的vertex，并起来，形成的 可重复集合(multiset) 是否为 $\\{1,2,3,\u0026hellip;,n\\}$ 即可！\n我们可以预处理出 对于每一个 $j$，如果 $c_j = x$，所指向的vertex组成的集合。然后在枚举 $(c_1,c_2,\u0026hellip;,c_k)$ 的时候，判断一下这些集合的并集是否为 $\\{1,2,3,\u0026hellip;,n\\}$ 即可！\n那么，如何快速的\n 判断集合是否相等 和 求可重复并集 呢？  使用Hashing！\n 我们要定义一种Hash函数，使得上述两个操作的速度为 $O(1)$ 。\n在字符串哈希中，我们用字符的位置来hash，但是因为我们不关心集合中元素的顺序，所以可以用集合中元素的value来hash！\n假设给定一个集合 $\\{a_1,a_2,\u0026hellip;,a_m\\}$，定义哈希值为：$\\sum\\limits_{i=1}^mp^{a_i} = p^{a_1} + p^{a_2} + \u0026hellip; + p^{a_m}$，这样：\n 判断集合是否相等：直接比较两个集合的哈希值 求两个集合的可重复并集：直接将两个集合的哈希值相加   代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 2e5+5; const ll p = 31; int n,m,k; vector\u0026lt;pii\u0026gt; adj[maxn]; // {w, to} int out[maxn]; vector\u0026lt;int\u0026gt; deg[10]; // store vertices with deg x ll pow31[maxn]; ll ha[10][10]; //ha[i][j] 代表 c_i=j时，所指向的vertex的并集的哈希值 ll tar = 0; // {1,2,3...,n}对应的哈希值 int ans = 0; void init() { pow31[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) pow31[i] = (pow31[i-1] * p) % mod; for (ll i = 1; i \u0026lt;= n; i++) tar += pow31[i]; tar %= mod; for (int i = 1; i \u0026lt;= k; i++) { // calculate all vertex with deg i for (int j = 1; j \u0026lt;= i; j++) { // if c_i = j for (int a : deg[i]) { int to = adj[a][j-1].second; (ha[i][j] += pow31[to]) %= mod; } } } } void dfs(int dep, ll cur) { //cur: current hash value if (dep == k+1) { if (tar == cur) ans++; return; } for (int j = 1; j \u0026lt;= dep; j++) { dfs(dep+1, (cur + ha[dep][j]) % mod); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; adj[u].push_back({w,v}); out[u]++; } for (int i = 1; i \u0026lt;= n; i++) { sort(adj[i].begin(), adj[i].end()); deg[out[i]].push_back(i); } init(); dfs(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   其他例题(TODO)  https://www.luogu.com.cn/problem/P6688 https://www.luogu.com.cn/problem/P3792  ","date":"2021-02-25T15:25:22+08:00","permalink":"https://tom0727.github.io/post/012-cf-1395e/","tags":["哈希","图论"],"title":"CF 1395E(集合哈希)"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1492/problem/E\n题意\n给定 $n$ 个长度为 $m$ 的正整数array，其中 $n \\geq 2, m \\geq 1, n \\times m \\leq 250000$\n问是否存在一个array，使得这个array 与 其他每个array的difference（不同元素的个数） $\\leq 2$？\n 题解 暴搜，我们可以先令 $ans$ 等于第一个array，然后看一下其他array中，有没有 $diff \u0026gt; 2$ 的，如果有，尝试更改 $ans$ 中的一个元素，更改后再看一下其他array的difference情况，如果还是不行，就继续尝试更改其他元素。 直到所有array的 $diff \\leq 2$\n注意到，因为$ans$基于第一个array，所以最多只能更改两个元素，我们可以给在搜索的时候设置一个深度 left，代表还可以更改几个元素。一开始就是dfs(2)。\n 注1: 本题时限卡的比较紧，时限为2s，我们可以设定2s内如果搜索不出结果就直接返回\u0026quot;No\u0026rdquo;。\ndouble start = clock(); double passed = clock() - start; if (passed \u0026gt; 1950.0) { // 1950ms cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot; exit(0); }    注2: 暴搜的时候记得回溯！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; arr; vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; cnt; double start; inline bool check() { for (int i = 0; i \u0026lt; n; i++) { if (cnt[i] \u0026gt; 2) return 0; } return 1; } void dfs(int left) { if (left \u0026lt; 0) return; if (clock()-start \u0026gt; 1950) { printf(\u0026quot;No\\n\u0026quot;); exit(0); } for (int i = 0; i \u0026lt; n; i++) { cnt[i] = 0; vector\u0026lt;int\u0026gt; pos; for (int j = 0; j \u0026lt; m; j++) { if (ans[j] != arr[i][j]) { cnt[i] += 1; pos.push_back(j); } } if (cnt[i]-left \u0026gt; 2) { return; } if (cnt[i] \u0026gt; 2) { for (int j : pos) { int pre = ans[j]; ans[j] = arr[i][j]; dfs(left-1); ans[j] = pre; //记得回溯 } } } if (check()) { printf(\u0026quot;Yes\\n\u0026quot;); for (int j = 0; j \u0026lt; m; j++) printf(\u0026quot;%d \u0026quot;, ans[j]); printf(\u0026quot;\\n\u0026quot;); exit(0); } } int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); start = clock(); arr = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; (n, vector\u0026lt;int\u0026gt;(m,0)); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i][j]); } } ans = arr[0]; cnt = vector\u0026lt;int\u0026gt;(n,0); dfs(2); printf(\u0026quot;No\\n\u0026quot;); }  ","date":"2021-02-24T22:27:41+08:00","permalink":"https://tom0727.github.io/post/011-cf-1492e/","tags":["搜索","dfs优化"],"title":"CF 1492E(暴搜)"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些关于HTML,CSS,JS的知识点\nCSS 当前页面的selector 假设我们有一个nav bar，有很多个link，我们希望检测当前在哪个页面，然后让当前页面对应的link的img更换一个，怎么办？（不使用javascript，仅用CSS）\n方案 可以用CSS中的 Pseudo-classes 中的 target，当网页链接中存在 #some_id 时，所有 id = \u0026quot;some_id\u0026quot; 的tag就会变成 :target 的状态。\n所以可以给每个 a 的 href 加上一个 #some_id，然后给 img 加上 id = some_id，如下：\nHTML代码 \u0026lt;nav\u0026gt; \u0026lt;div\u0026gt; \u0026lt;a href=\u0026quot;index.html#index\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/1.jpg\u0026quot; id=\u0026quot;index\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;aboutus.html#about\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/2.jpg\u0026quot; id=\u0026quot;about\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;staff.html#staff\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/3.jpg\u0026quot; id=\u0026quot;staff\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt;   CSS代码 这里以index为例：\nnav \u0026gt; div \u0026gt; a[href*=\u0026quot;index\u0026quot;] \u0026gt; img:target { content:url(\u0026quot;images/index_selected.jpg\u0026quot;); }   参考链接  https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target  HTML/CSS 手机字体大小不一 在手机上发现font-size相同的字体大小不一致，怎么办？\n方案   在HTML文件前面加上\n\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1\u0026quot;\u0026gt;    添加上述代码后，网页中可能会出现 horizontal scrollbar。可以在css中添加：\n@media only screen and (max-width: 600px) { html, body { overflow-x: hidden; } body { position: relative; } }  然后在 media query 里面调整一下字体大小，图片大小之类的属性，保证 overflow-x: hidden; 不会隐藏内容。\n  参考链接  https://stackoverflow.com/questions/27074259/html-css-table-font-size-different-in-mobile-device https://stackoverflow.com/questions/4192277/disable-horizontal-scroll-on-mobile-web  ","date":"2021-02-21T23:39:36+08:00","permalink":"https://tom0727.github.io/post/010-%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/","tags":["前端","HTML","js","css"],"title":"HTML/CSS/JS笔记"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些关于vim的知识点\nHTML Match Tags 我们想要显示opening/closing tag的matching情况，并且从一个opening tag跳转到closing tag怎么做？\n方案  在vscode下载一个叫 Highlight Matching Tag 的插件 下载叫做 matchit 的vim插件，放在本地的 ~/.vimrc/plugin/ 下（如果没有plugin文件夹，就创建一个），在.vimrc里添加 filetype plugin on runtime macros/matchit.vim  这样就可以用 % 进行跳转了。\n vscode上似乎不能装插件，可以把cursor移动到tag上，然后按 esc 进入normal mode，然后 v a t 跳转到matching tag  参考链接  https://stackoverflow.com/questions/7281459/matchit-not-working https://vi.stackexchange.com/questions/780/how-to-jump-between-matching-html-xml-tags  ","date":"2021-02-20T23:15:28+08:00","permalink":"https://tom0727.github.io/post/009-vim/","tags":["vim"],"title":"vim笔记"},{"categories":["算法"],"contents":"介绍 树形dp就是在树上进行dp，常用于 \u0026ldquo;树上选一组点/边，满足某些条件，且使得某些权值和最大\u0026rdquo; 的问题。\n树形dp实现过程中也有很多需要注意的点，以下放一道经典例题：\n例题 例1 洛谷P2014 题意\n有 $N$ 门课程，每门课程有 $1$ 或 $0$ 门前置课程，需要上了前置课程才能上这门课。每门课 $i$ 有 $s_i$ 学分。\n现要选 $M$ 门课，使得学分总和最大。\n 题解 设 $dp[i][j]$ 为: 以 $i$ 为根的子树当中，选了 $j$ 个课程得到的最大值\n根据前置课程的关系建图(会发现这是一棵树)，因为有前置课程，所以必须选了root才能选别的，故:\n$dp[i][1] = s_i$\n在处理某一个节点i的时候，$dp[i][j]$ 代表的是： 以它为root的 \u0026ldquo;已探索\u0026rdquo; 子树中的最大值，所以在探索各个子树过程中有：\n$dp\\left[cur\\right]\\left[j\\right]=\\max\\left(dp\\left[cur\\right]\\left[j\\right],dp\\left[cur\\right]\\left[k\\right]+dp\\left[nei\\right]\\left[j-k\\right]\\right),\\ k=\\left[1,j-1\\right]$\n 实现细节\n 我们利用 $dp[i][1] = s_i$ 来处理前置课程，是非常高效的做法！ 状态转移的时候，要 倒序枚举 $j$， 也就是 $j = m \u0026hellip; 1$， 因为此时 $dp[cur][k]$ 代表的是已探索的部分，不能包括 $nei$ (因为 $nei$ 正在被探索)。为了防止同一个 $nei$ 被考虑多次，要倒序枚举！ 给定的图可能是一个森林，所以创建一个超级root $0$，并且将 $M$++ (因为 $0$ 肯定要包含进去)，最终答案就是 $dp[0][M+1]$   算法优化\n注意，在dp状态转移的时候，我们可能用的是如下loop:\nfor (int j = m; j \u0026gt;= 1; j--) { for (int k = 1; k \u0026lt;= j-1; k++) { dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  每个节点 cur 都这样loop一次，总复杂度是 $O(nm^2)$，看起来不可接受。\n我们可以优化一下：\n对于每一个root节点 cur，我们记录一下 int sz[cur]，代表 以cur为根的子树的节点数量， 这样枚举的时候我们就可以优化成这样：\nfor (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  时间复杂度：$O(n^2)$\n证明：我们考虑每一个 nei 被用来转移 的次数，会发现它只会在计算它的 parent 的dp值时才会被拿来统计，又因为每一个节点只有1个parent，所以每个节点对应的子树都只会被统计一次。\n所以时间复杂度就是 $T(\\sum\\limits_{i=1}^n i * sz[i]) = O(n^2)$\n更严谨的数学证明可以参见 https://www.luogu.com.cn/blog/Chenxiao-Yan/solution-p4322\n luogu-P2014-AC代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 305; const int maxm = 305; int n,m; int s[maxn]; int dp[maxn][maxn]; int sz[maxn]; //记录i的子树大小 struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void init() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); fill(head, head+n+2, -1); //因为存在编号为0的节点，所以初始化为-1 for (int i = 1; i \u0026lt;= n; i++) { int sc,k; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;k,\u0026amp;sc); s[i] = sc; add(k, i); } } void dfs(int cur, int par) { if (sz[cur]) return; // visited dp[cur][1] = s[cur]; sz[cur] = 1; for (int e = head[cur]; ~e; e = edges[e].nxt) { int nei = edges[e].to; if (par == nei) continue; dfs(nei, cur); sz[cur] += sz[nei]; for (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } } } } int main() { init(); m++; dfs(0, -1); printf(\u0026quot;%d\\n\u0026quot;, dp[0][m]); }    题外话：如果每门课的前置课程不止1门，就不再是一棵树了，这样的话似乎可以用状压dp来解，leetcode某次比赛中出现过。\n ","date":"2021-02-18T15:42:09+08:00","permalink":"https://tom0727.github.io/post/008-%E6%A0%91%E5%BD%A2dp/","tags":["树形dp","dp优化"],"title":"树形dp"},{"categories":["算法"],"contents":"介绍 01分数规划用于 求一个分式的极值\n例如： 给定 $a_i, b_i$，选出一组$i$， 使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大/最小？\n方法 (二分) 一般使用二分答案的方法进行求解，假设我们要求最大值，那么 二分一个答案 $mid$，有\n$\\frac{\\sum a_i}{\\sum b_i} \\geq mid$, 所以\n$\\sum a_i- (mid \\times b_i) \\geq 0$\n所以只要求出左边的最大值，判断是否 \u0026gt;= 0 即可！\n 如果左边最大值 \u0026gt;= 0，说明当前答案 $mid$ 可行，提高下边界 如果左边最大值 \u0026lt; 0，说明当前答案 $mid$ 不可行，降低上边界  例题 例1 POJ2976 Dropping tests 题意\n有 n 个物品，每个物品 $i$ 有两个权值 $a_i, b_i$。\n选 $k$ 个物品 ，使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大。\n 题解 二分答案，当前答案为 $mid$ 时，把第 $i$ 个物品的权值设为 $a_i - mid \\times b_i$，然后取最大的 $k$ 个即可得到最大值。\n 例2 洛谷P1419 题意\n给定 $n$ 个整数，求一个长度在 $[S,T]$ 之间的subarray(连续)，使得平均值最大？\n 题解 二分答案，当前答案为 $mid$ 时，我们遍历一下区间的右端点 $r$，从 $1$ 遍历到 $n$，固定一个 $r$，则我们需要找到 左端点 $l$ 使得 $\\frac{\\sum\\limits_{i=l}^ra_i}{r-l+1}$ 最大。\n令 $\\frac{\\sum\\limits_{i=l}^ra_i}{r-l+1} \\geq mid$，有 $\\sum\\limits_{i=l}^r(a_i - mid) \\geq 0$，\n定义一个新的数组$b$，其中 $b_i = a_i - mid$。\n左边的最大值就是 $b$ 这个数组中最大的连续区间，用前缀和即可。\n 另外一种思考方法:\n二分答案，当前答案为 $mid$ 时，我们遍历一下区间的右端点 $r$，从 $1$ 遍历到 $n$，固定一个 $r$，则我们需要找到 左端点 $l$ 使得 $\\frac{sum[r] - sum[l-1]}{r-l+1}$ 最大。\n$\\frac{sum[r] - sum[l-1]}{r-l+1} \\geq mid$ ，有 $(mid \\times (l-1) - sum[l-1]) - (mid \\times r - sum[r]) \\geq 0$\n因为 $r$ 固定，所以只要找 $mid*l - sum[l]$ 的最大值，其中 $l \\in [\\max(0, r-T), r-s]$。\n遍历 $r$ 的时候，维护一个单调队列即可。\n luogu-P1419-AC代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = (double)1e-6; const int maxn = 1e5+5; int n, s, t; int arr[maxn]; int sum[maxn]; double a[maxn]; int q[maxn]; int head = 0, tail = -1; double ans = -1e4; bool check(double cur) { for (int i = 0; i \u0026lt;= n; i++) a[i] = cur * (double)(i) - (double)(sum[i]); double res = -1e18; head = 0, tail = -1; for (int r = s; r \u0026lt;= n; r++) { while (head \u0026lt;= tail \u0026amp;\u0026amp; q[head] \u0026lt; r-t) head++; while (head \u0026lt;= tail \u0026amp;\u0026amp; a[q[tail]] \u0026lt; a[r-s]) tail--; q[++tail] = r-s; res = max(res, a[q[head]] - a[r]); } // for (int r = 1; r \u0026lt;= n; r++) { // double tmp = -1e18; // for (int i = max(0, r-t); i \u0026lt;= r-s; i++) { // tmp = max(tmp, a[i]); // } // res = max(res, tmp - a[r]); // } if (res \u0026gt;= 0) return 1; return 0; } int main() { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;s,\u0026amp;t); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i]); sum[i] = sum[i-1] + arr[i]; } double l = -1e4, r = 1e4; while (abs(l-r) \u0026gt; eps) { double mid = (l+r) * 0.5; if (check(mid)) { l = mid; ans = mid; } else { r = mid; } } printf(\u0026quot;%.3f\\n\u0026quot;, ans); }   例3 洛谷P4377 题意\n有 n 个物品，每个物品 $i$ 有两个权值 $a_i, b_i$。\n你可以选 $k$ 个物品 ，使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大, 且 $\\sum b_i \\geq W$\n 题解 和例1几乎一样，但是多了一个 $\\sum b_i \\geq W$ 的限制。\n设 $d_i = a_i - mid \\times b_i$，然后我们要做的事就是：\n选取一组$i$，保证在 $\\sum b_i \\geq W$ 的前提下，使得 $\\sum d_i$ 最大\n可以用01背包解决，令 $dp[n][k]$ 为：使用前 $n$ 个元素，$\\sum b_i = k$ 时， $\\sum d_i$ 的最大值。\n那么答案就是 $dp[n][W]$。\n如果在状态转移过程中出现 $k \u0026gt; W$，直接转移到 $k = W$ 的状态上即可。\n 注: 写01背包的时候不要忘了 倒序枚举 ！\n  luogu-P4377-AC代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const double eps = (double)1e-6; const int maxn = 255; int n,W; int w[maxn], t[maxn]; double dp[1001]; struct node { double d; int w; } arr[maxn]; bool check(double cur) { for (int i = 1; i \u0026lt;= n; i++) { arr[i] = {(double)t[i] - cur * (double)w[i], w[i]}; } fill(dp, dp+1001, -1e9); dp[0] = 0.0; for (int i = 1; i \u0026lt;= n; i++) { for (int d = 1000; d \u0026gt;= 0; d--) { int tar = min(d + arr[i].w, 1000); dp[tar] = max(dp[tar], dp[d] + arr[i].d); } } for (int d = W; d \u0026lt;= 1000; d++) { if (dp[d] \u0026gt;= 0.0) return 1; } return 0; } int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n,\u0026amp;W); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;w[i], \u0026amp;t[i]); } double l = 0.0, r = 1e6, ans = 0.0; while (abs(l-r) \u0026gt;= eps) { double mid = (l+r) * 0.5; if (check(mid)) { l = mid; ans = max(ans, mid); } else { r = mid; } } printf(\u0026quot;%d\\n\u0026quot;, (int)((ans+5e-5) * 1000)); }   例4 洛谷P4322 题意\n给定一棵$N$个节点的树，每个节点 $i$ 具有两个权值 $P_i, S_i$，求树中的一组节点，满足：\n $\\frac{\\sum\\limits_i P_i}{\\sum\\limits_i S_i}$ 最大 如果 节点 $i$ 被选中了，那么它的parent $R_i$ 也必须被选中 选中的节点数量 刚好为$K$  求满足条件的最大比值？\n 题解 首先看条件1：$\\frac{\\sum\\limits_i P_i}{\\sum\\limits_i S_i}$ 最大，仍然是分数规划的套路，二分答案。令 $d_i = P_i - mid \\times S_i$\n所以问题转化为求一组节点使得 $\\sum d_i$ 最大。\n然后就会发现，这是一个经典的树形dp模型，和 选课(洛谷P2014) 几乎一样。\n具体做法和注意事项见下一篇博客。\n","date":"2021-02-17T17:20:49+08:00","permalink":"https://tom0727.github.io/post/007-01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","tags":["01分数规划","二分"],"title":"01分数规划"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1159/problem/B\n题意\n给定 $n$ 个非负整数 $a_1,a_2,\u0026hellip;,a_n$，求 $\\frac{\\min(a_i, a_j)}{|i-j|}$ ？其中 $i, j \\in [1,n], i \\neq j$\n 题解 对于这类的枚举问题，一般套路都是 \u0026ldquo;固定一个数\u0026rdquo;，这里很明显是固定一下 $\\min(a_i, a_j)$。\n所以只要从 $a_1$ 遍历到 $a_n$，把当前遍历到的值作为最小值，然后不管最左侧或者最右侧元素是否小于它，直接最大化分母就可以了。\n为什么不会漏解？因为 每一个 $a_i$ 都当了一次分子！\n 代码 const int maxn = 3e5+5; int n, arr[maxn]; int ans = 1e9; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= n; i++) { int d = max(i-1, n-i); ans = min(ans, arr[i] / d); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-02-17T15:19:54+08:00","permalink":"https://tom0727.github.io/post/006-cf-1159b/","tags":["枚举"],"title":"CF1159B 题解(枚举优化)"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些爬虫相关的知识点：\n分段下载 如果我们需要设定下载的timeout怎么办？\n直接指定 requests.get() 中的 timeout 是不行的！因为这里的timeout参数意义是 \u0026ldquo;从服务器返回任意数据\u0026rdquo; 的时间差。如果我们想要设定 timeout 使得在一定时间内下载不完就break，可以用分段下载！\n分段下载由stream=True实现\ndef download_img(img_url, path): timeout = 150 # 设定150秒如果下载不完就停止下载 try: img_html = requests.get(img_url, headers=get_download_header(), timeout=10, stream=True) if img_html.status_code != 200: return body = [] start = time.time() for chunk in img_html.iter_content(1024): body.append(chunk) if time.time() \u0026gt; start + timeout: print(\u0026quot;Time out!\u0026quot;) break else: # 下载完毕 with open(path, 'wb') as file: file.write(b''.join(body)) file.flush() except BaseException as err: print(err)  多进程下载 多进程下载经常在访问一些速度较慢的网站时很有用，因为本地的带宽不是主要限制，所以可以开很多个进程同时访问然后进行下载，这样更快。\ndef f(arg): ... # 下载程序 if __name__ == '__main__': processes = [] for _ in range(20): p = multiprocessing.Process(target=f, args=(some_arg, )) p.start() processes.append(p) for p in processes: p.join()  正则表达式Regex的注意事项   匹配时注意区分懒惰匹配和贪婪匹配，懒惰匹配可以在匹配符号后加上?，如 .*?\n  如果在匹配过程中需要用到()，但是需要获取整个匹配结果（不想被()框起来的部分干扰），可以使用non-capturing group，即，(?:)，如:\nre.findall(\u0026quot;https://abc.net/images/.*?(?:jpg|png|jpeg)\u0026quot;, txt)\n这样，返回的就是整个匹配的网址，而不是()框起来的部分\n  ","date":"2021-02-10T22:52:26+08:00","permalink":"https://tom0727.github.io/post/005-%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/","tags":["爬虫","python"],"title":"爬虫笔记"},{"categories":["算法"],"contents":"定义 给定正整数$n$，求$\\varphi(n)$， 即\n 小于等于$n$ 且 与$n$互质  的正整数个数。\n性质  $\\varphi(p) = p-1, ~\\forall \\text{prime } p$ $\\varphi(mn) = \\varphi(m)\\varphi(n) \\iff \\gcd(m,n) = 1$ $\\varphi(p^k) = p^k - p^{k-1} = p^k(1-\\frac{1}{p})$ $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}, ~\\varphi(n) = n\\prod_{i=1}^{r}(1-\\frac{1}{p_i}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$ $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$, 如果 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$, 则 $\\varphi(n) = \\varphi(\\frac{n}{p_i})*p_i$  证明 证明性质1 求证： $\\varphi(p) = p-1, ~\\forall \\text{prime } p$\n 由质数的定义可知，小于等于$p$ 且 与$p$互质的数，在$[1,p]$中，除了 $p$以外均满足！\n 注： $\\varphi(1) = 1$\n 证明性质2 求证： $\\varphi(mn) = \\varphi(m)\\varphi(n) \\iff \\gcd(m,n) = 1$\n 首先，易知 $\\varphi(n) = |\\mathbb{Z}_n^{\\times}|$ , 即 $\\mathbb{Z}_n$ 中 unit(存在关于$\\bmod~ n$乘法逆元的元素)的数量\n因为 $\\mathbb{Z}_{mn} \\cong \\mathbb{Z}_m \\times \\mathbb{Z}_n \\iff \\gcd(m,n) = 1$\n所以 $\\mathbb{Z}_{mn}$的units $\\mathbb{Z}_{mn}^{\\times}$ ， 与\n$\\mathbb{Z}_m \\times \\mathbb{Z}_n$的 units $(\\mathbb{Z}_m \\times \\mathbb{Z}_n)^{\\times}$ 之间存在一个 bijection, 即\n$\\mathbb{Z}_{mn}^{\\times} \\cong (\\mathbb{Z}_m \\times \\mathbb{Z}_n)^{\\times} = \\mathbb{Z}_m^{\\times} \\times \\mathbb{Z}_n^{\\times}$\n所以 $\\varphi(mn) = |\\mathbb{Z}_{mn}^{\\times}| = |\\mathbb{Z}_m^{\\times} \\times \\mathbb{Z}_n^{\\times}| = |\\mathbb{Z}_m^{\\times}||\\mathbb{Z}_n^{\\times}| = \\varphi(m)\\varphi(n)$\n 注：\n $\\mathbb{Z}_{mn} \\cong \\mathbb{Z}_m \\times \\mathbb{Z}_n \\iff \\gcd(m,n) = 1$ 的证明见 这里 更严格的证明需要用到抽代里的中国剩余定理 （以Ring和Ideal表示的）   证明性质3 求证：$\\varphi(p^k) = p^k - p^{k-1} = p^k(1-\\frac{1}{p})$\n $\\forall n = p^k$，所有与它不互质的数$m$必然包含$p$这个质数因子，因此满足条件的$m$为：$1p, 2p, 3p, \u0026hellip; , p^{k-1}p$，共 $p^{k-1}$个。\n所以，与$n = p^k$互质的数共有 $p^k-p^{k-1}$个。\n  证明性质4 求证：$\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}, ~\\varphi(n) = n\\prod_{i=1}^{r}(1-\\frac{1}{p_i}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$\n 因为 $n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，且$p_1,p_2,\u0026hellip;,p_r$都是质数（所以两两互质）\n由性质2， $\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip;\\varphi(p_r^{k_r})$\n由性质3，$\\varphi(p_i^{k_i}) = p_i^{k_i} - p_i^{k_i-1} = p_i^{k_i}(1-\\frac{1}{p_i})$\n所以 $\\varphi(n) = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$\n  证明性质5 求证：$\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$, 如果 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$, 则 $\\varphi(n) = \\varphi(\\frac{n}{p_i})*p_i$\n 因为 $n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，\n由性质2，$\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip;\\varphi(p_r^{k_r})$\n由性质3， $\\varphi(p^k) = p^k - p^{k-1}$, 我们可以推出 $\\varphi(p^{k+1}) = \\varphi(p^{k}) * p$\n因为 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$，由上可得出 $\\varphi(p_i^{k_i}) = \\varphi(p_i^{k_i-1}) * p_i$\n即 $\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip; (\\varphi(p_i^{k_i-1})*p_i)\u0026hellip;\\varphi(p_r^{k_r}) = \\varphi(\\frac{n}{p_i})*p_i$\n  求单个数的欧拉函数值 $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，直接质因数分解，由性质4即可求出！\n时间复杂度：$O(\\sqrt n)$\n代码 ll phi(ll x) { ll res = x; for (ll p = 2; p * p \u0026lt;= x; p++) { if (x % p == 0) { res = (res / p) * (p-1); } while (x % p == 0) x /= p; } if (x \u0026gt; 1) res = res / x * (x-1); return res; }  线性筛求1~n的欧拉函数值 和线性筛的基本思路一样，只不过要分类讨论 i % p == 0 与否。（i是当前处理到的数, p是当前用到的质数）\n  如果 i % p == 0，说明 i * p 这个数里，包含了至少2个质因子$p$ (即$p^2$)。\n由性质5，有 $\\varphi(i * p) = \\varphi(i) * p$\n  如果 i % p != 0，说明 $\\gcd(i,p) = 1$。\n由性质2，有 $\\varphi(i * p) = \\varphi(i) * \\varphi(p)$\n  时间复杂度： $O(n)$\n代码 luogu-P2158-AC代码 题目链接: https://www.luogu.com.cn/problem/P2158\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244352; const int maxn = 4e4+5; int phi[maxn]; bool p[maxn]; vector\u0026lt;int\u0026gt; primes; int main() { int n; cin \u0026gt;\u0026gt; n; if (n \u0026lt;= 1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } phi[1] = 1; fill(p, p+maxn, 1); for (int i = 2; i \u0026lt;= n; i++) { if (p[i]) { phi[i] = i-1; primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= n; j++) { int cur = primes[j]; p[i*cur] = 0; if (i % cur == 0) { phi[i*cur] = phi[i] * cur; break; } else { phi[i*cur] = phi[i] * phi[cur]; } } } int ans = 3; for (int i = 2; i \u0026lt;= n-1; i++) ans += 2*phi[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例题 例1 CF1295 题意\n给定两个正整数 $a$, $m$, 求满足以下条件的 $x$ 的数量？\n $0 \\leq x \u0026lt; m$ $\\gcd(a,m) = \\gcd(a+x,m)$  其中，$1 \\leq a \u0026lt; m \\leq 10^{10}$\n 题解 设 $g = \\gcd(a,m)$，则 $g = \\gcd(a+x,m)$，所以 $\\gcd(\\frac{a+x}{g}, \\frac{m}{g}) = 1~$ 且 $~g|(a+x)$，又因为 $g|a$，所以 $~g|x$\n所以问题转化为：\n设 $c = \\frac{a}{g}, x = \\frac{m}{g}$，求 $k \\in [c,c+x)$，使得 $k$ 满足：$gcd(x, k) = 1$ 的 $k$ 的数量？\n我们会发现当 $k \u0026gt; x$ 时，因为 $\\gcd(x,k) = \\gcd(x, k-x)$，所以我们可以将 $k \\in (x,c+x)$ 的这一段，映射到 $k \\in (0,c)$ 上。\n所以最后我们要求的$k$就是： $k \\in [1,x]$ 使得 $\\gcd(k, x) = 1$，所以满足条件的 $k$ 的数量就等于 $\\varphi(x)$\n 参考链接  https://blog.csdn.net/paxhujing/article/details/51353672 https://www.luogu.com.cn/blog/JustinRochester/solution-p2158 https://blog.nowcoder.net/n/0cbf747dc0874027b5c48cf7fbf27060  后记 写这篇文章的时候出了几个数学公式上的问题:\n 如果排版炸了，可以试着在 _ 的前面加上 \\  ","date":"2021-02-06T17:23:34+08:00","permalink":"https://tom0727.github.io/post/004-euler-function/","tags":["数学","抽代"],"title":"欧拉函数"},{"categories":["算法"],"contents":"中国剩余定理 (crt) 定义 给定方程组： $$\\begin{cases} x\\equiv a_1 (\\text{mod }m_1) \\\\\nx\\equiv a_2 (\\text{mod }m_2) \\\\\n\u0026hellip; \\\\\nx\\equiv a_k (\\text{mod }m_k) \\\\\n\\end{cases}$$\n其中 $a_i \\geq 0, m_i \u0026gt; 0, a_i,m_i \\in \\mathbb{Z}$, 且 $m_i$ 之间两两互质。\n求满足条件的最小非负整数解 $x$ ？\n结论 令 $M = m_1 \\cdot m_2 ~\u0026hellip; ~m_k$, $M_i = \\frac{M}{m_i}$\n令 $M_i^{-1}$ 为 $M_i$ 在 $\\color{red} \\text{mod }m_i$ 意义下的逆元\n则，答案为: $x = \\sum\\limits_{i=1}^{k}a_iM_iM_i^{-1} ~ (\\text{mod }M)$\n证明 因为 $\\forall i \\neq j, M_i \\equiv 0 ~(\\text{mod } m_j)$\n所以 $\\forall i \\neq j, a_iM_iM_i^{-1} \\equiv 0~ (\\text{mod } m_j)$\n所以 $\\forall i, x \\equiv \\sum\\limits_{i=1}^{k}a_iM_iM_i^{-1} \\equiv a_iM_iM_i^{-1} ~ (\\bmod ~m_i)$\n又因为 $\\forall i, M_iM_i^{-1} \\equiv 1 ~(\\text{mod } m_i)$\n所以 $\\forall i, x \\equiv a_iM_iM_i^{-1} \\equiv a_i ~ (\\text{mod } m_i)$\n证明推导过程 证明推导过程 这里直接放参考链接一中的片段：\n 由于 $M = 3\\times5\\times7 = 105$\n所以最后的解就是 $x = (n_1 + n_2 + n_3) ~\\bmod ~ 105 = 233 ~ \\bmod 105 = 23$\n  例题  https://www.luogu.com.cn/problem/P3868  快速乘 在题目中，有可能出现 $\\bmod$ 接近 $1e18$ 的情况，有可能会爆 long long，所以在计算大数乘法时，要用快速乘（原理类似于快速幂）：\nll qmul(ll a, ll b) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % mod; b \u0026gt;\u0026gt;= 1; a = (a + a) % mod; } return ans; }  模版 luogu-P3868-AC代码 题目链接: https://www.luogu.com.cn/problem/P3868\n#include \u0026lt;bits/stdc++.h\u0026gt; #define fastio ios::sync_with_stdio(false); cin.tie(0); #define ll long long ll M = 1; ll qmul(ll a, ll b) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % M; b \u0026gt;\u0026gt;= 1; a = (a + a) % M; } return ans; } ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll curx = y; ll cury = x - (a/b) * y; x = curx; y = cury; return g; } ll a[15], b[15]; int k; ll crt() { ll ans = 0; for (int i = 1; i \u0026lt;= k; i++) { ll m = M / b[i]; ll x,y; exgcd(m, b[i], x, y); if (x \u0026lt; 0) x += b[i]; ans = (ans + qmul(qmul(a[i], m), x)) % M; } return ans; } int main() { fastio; cin \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= k; i++) cin \u0026gt;\u0026gt; b[i], M *= b[i]; for (int i = 1; i \u0026lt;= k; i++) { a[i] -= (a[i]/b[i]) * b[i]; //将a[i]变成正数 a[i] += b[i]; a[i] %= b[i]; } cout \u0026lt;\u0026lt; crt() \u0026lt;\u0026lt; endl; }   参考链接  https://zhuanlan.zhihu.com/p/103394468  拓展中国剩余定理 (excrt) 定义 用于 $m_1,m_2,\u0026hellip;,m_k$ 并不互质的情况\n给定方程组： $$\\begin{cases} x\\equiv a_1 (\\text{mod }m_1) \\\\\nx\\equiv a_2 (\\text{mod }m_2) \\\\\n\u0026hellip; \\\\\nx\\equiv a_k (\\text{mod }m_k) \\\\\n\\end{cases}$$\n其中 $a_i \\geq 0, m_i \u0026gt; 0, a_i,m_i \\in \\mathbb{Z}$，（$m_i$ 之间无特殊关联）\n求满足条件的最小非负整数解 $x$ ？\nIntuition 先看一些简单的例子：\n$$\\begin{cases} x\\equiv 2 ~(\\text{mod }4) \\\\\n\\\\\nx\\equiv 4 ~(\\text{mod }6) \\\\\n\\end{cases}\\Longrightarrow x \\equiv 10 ~(\\text{mod } 12)$$\n$$\\begin{cases} x\\equiv 4 ~(\\text{mod }6) \\\\\n\\\\\nx\\equiv 3 ~(\\text{mod }5) \\\\\n\\end{cases}\\Longrightarrow ~\\varnothing$$\n可以看出几个特点：\n 答案的 $\\text{mod}$ 为 $\\text{lcm}(m_1, m_2)$ 有可能无解 （若$m_1,m_2$互质则必然有解）  推导 考虑 $x$ 满足：\n$$\\begin{cases} x\\equiv a_1 ~(\\text{mod }m_1) \\\\\n\\\\\nx\\equiv a_2 ~(\\text{mod }m_2) \\\\\n\\end{cases}$$\n则有 $x = k_1m_1 + a_1 = k_2m_2 + a_2$\n 即：$k_1m_1 - k_2m_2 = a_2 - a_1$\n这个方程有解 $\\iff \\gcd(m_1,m_2) | (a_2 - a_1)$ （即 $(a_2 - a_1)$ 是 $\\gcd(m_1,m_2)$ 的倍数）。\n 如果无解，就直接退出。\n如果有解，就用 $exgcd(m_1, m_2, x\u0026rsquo;, y\u0026rsquo;)$ 解出 $k_1$ 的值。\n设 $\\gcd(m_1, m_2) = g$，则 $k_1 = x\u0026rsquo; \\cdot\\frac{a_2 - a_1}{g}$\n然后将 $k_1$ 代入 $x = k_1m_1 + a_1$，得到 $x$ 的值，答案就是 $x \\equiv (k_1m_1 + a_1) (\\text{mod ~lcm}(m_1,m_2))$\n这样，$2$个同余方程就转化为了$1$个，用同样的方法继续进行下去，即可化为一个同余方程。\n最终的 $\\text{mod}$ 数就是 $M = \\text{lcm}(m_1, m_2, m_3 \u0026hellip; , m_n)$\n模版 luogu-P4777-AC代码 题目链接: https://www.luogu.com.cn/problem/P4777\nusing namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e5+5; ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll x2 = x, y2 = y; x = y2, y = x2 - a/b * y2; return g; } ll mul(ll a, ll b, ll mod) { ll res = 0; while (b) { if (b\u0026amp;1) (res += a) %= mod; (a += a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } int n; ll a[maxn], m[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; m[i] \u0026gt;\u0026gt; a[i]; ll cura = a[1], curm = m[1]; for (int i = 2; i \u0026lt;= n; i++) { /* m1 = curm, m2 = m[i], a1 = cura, a2 = a[i] */ ll x,y; ll g = exgcd(curm, m[i], x, y); // g = gcd(curm, m[i]) ll c = a[i] - cura; // c = a2 - a1 c = ((c % m[i]) + m[i]) % m[i]; // 处理负数，注意是 mod m2 (即 m[i]) if (c % g) { // 无解 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } ll M = (m[i] * (curm / g)); // M = lcm(m1, m2) ll k = mul(x, c / g, M); // k1 = x' * (a2-a1) / g cura = (mul(k, curm, M) + cura) % M; // x = k1m1 + a1 curm = M; } cout \u0026lt;\u0026lt; (cura % curm + curm) % curm \u0026lt;\u0026lt; endl; }   注意事项   我们需要处理可能出现的负数！（比如在快速乘的时候，如果 $b$ 为负数就会炸）\n 在 $exgcd(a,b,x\u0026rsquo;,y\u0026rsquo;)$ 中，$x'$ 有可能为负数。 $c = a_2 - a_1$，则 $c$ 也有可能为负数。  那么如何处理负数？我们需要找到这个负数对应的 $\\text{mod}$为多少，我们可以在等式 $k_1m_1 - k_2m_2 = a_2 - a_1$ 中找到！\n因为我们要求的是 $k_1$ 的值，实际上 $k_1m_1 = (a_2-a_1) + k_2m_2$，即 $k_1m_1 \\equiv (a_2-a_1) \\text{ (mod } m_2)$\n所以无论是 $k_1 = x\u0026rsquo; \\cdot\\frac{a_2 - a_1}{g}$ 还是 $(a_2-a_1)$，都取一个 $\\text{mod } m_2$ 即可！\n代码段：\nll c = a[i] - cura; c = ((c % m[i]) + m[i]) % m[i]; // 处理负数，注意是 mod m2 (即 m[i]) ll k = mul(x, c / g, M); // k = ((k % m[i]) + m[i]) % m[i]; 可以处理，但是没有必要，因为快速乘中的 a 可以为负数    注意快速乘过程中的 $\\text{mod}$ ！因为快速乘求的实际上是 $x$ 的值，所以 $\\text{mod } M$，其中 M = lcm(curm, m[i])\n  我们用 cura, curm 来维护当前的 同余方程，之后记得更新一下 curm = lcm(curm, m[i])\n  参考链接  https://www.luogu.com.cn/blog/blue/kuo-zhan-zhong-guo-sheng-yu-ding-li  ","date":"2021-02-06T10:46:42+08:00","permalink":"https://tom0727.github.io/post/003-crt/","tags":["数学","中国剩余定理","crt"],"title":"中国剩余定理介绍"},{"categories":["工程"],"contents":"写博客好累啊，是我太久没有写作了吗\n这次来记录一下我第一次学习爬虫的经历\n起因 补完とにかくかわいい的番，感觉真好看啊，漫画也不错，就打算补补とにかくかわいい的生肉漫画，但是这网站广告特别多，还会检测我adblocker，禁用javascript的话漫画就加载不出来了，气死我了，一怒之下决定学习爬虫把漫画爬下来看。\n爬虫教程有很多，这里特别推荐一个Jack Cui的教程：\n [资源分享] Python3 网络爬虫：漫画下载，动态加载、反爬虫这都不叫事\n 爬 manga1001.com 这个网站设置的比较粗糙，图片都是静态加载的(F12就能看见图片链接)，根据标签soup.find_all()一下即可。对于这个网站的话，简单说一下爬虫的基本流程吧。\n基本流程\n  观察一下页面的HTML，用F12打开可以看到大致结构，如果要看源代码的话，可以选择：\n1.1. res = requests.get(url), print(res.txt) 或\n1.2. 在url前加上view-source:，然后用浏览器打开。\n  找到包含图片的tag， 找一下规律，然后用 soup.find_all() 即可。\n  获取所有章节的URL，然后分别去每个URL里抓取。\n   参考代码 import requests from bs4 import BeautifulSoup import os import random import time def create_dir(path): if not os.path.exists(path): os.makedirs(path) root_folder = '/Users/huzhenwei/Desktop/manga/' create_dir(root_folder) USER_AGENTS = [ \u0026quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\u0026quot;, \u0026quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\u0026quot;, \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\u0026quot;, \u0026quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\u0026quot;, ] # get content of one chapter def get_content(folder, prefix, url): res = requests.get(url) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('figure') i = 1 folder_name = os.path.join(folder, f'Chapter_{prefix:03}/') create_dir(folder_name) for item in items: for child in item.children: if i != 1: img_url = child.get('data-src') else: img_url = child.get('src') print(img_url) headers = random.choice(USER_AGENTS) img_html = requests.get(img_url, headers) img_name = os.path.join(folder_name, f'{i:02}.jpg') with open(img_name, 'wb') as file: file.write(img_html.content) file.flush() i += 1 time.sleep(random.uniform(0, 3.33)) # sleep random time # get manga url list def get_url_list(manga_name, url): res = requests.get(url) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('option') for i in range(len(items) - 2, -1, -1): if items[i] == items[-1]: # get manga chapter url list without duplicates items = items[i+1:] break chapter = 1 folder = os.path.join(root_folder, f'{manga_name}/') for item in items: manga_url = item.get('value') get_content(folder, chapter, manga_url) print(manga_url) chapter += 1 def main(): url1 = \u0026quot;https://manga1001.com/%e3%80%90%e7%ac%ac1%e8%a9%b1%e3%80%91%e3%83%88%e3%83%8b%e3%82%ab%e3%82%af%e3%82%ab%e3%83%af%e3%82%a4%e3%82%a4-raw/\u0026quot; name1 = 'Tonikaku_Kawaii' get_url_list(name1, url1) url2 = \u0026quot;https://manga1001.com/%e3%80%90%e7%ac%ac1%e8%a9%b1%e3%80%91%e5%b9%b2%e7%89%a9%e5%a6%b9%e3%81%86%e3%81%be%e3%82%8b%e3%81%a1%e3%82%83%e3%82%93-raw/\u0026quot; name2 = 'Umaru_Chan' get_url_list(name2, url2) main()    注: 这里用的USER_AGENT和sleep()都是为了防止被发现然后封IP\n 爬 manhuagui.com 上面那个太没挑战性了，于是我打算再爬一个。\n打开漫画网站， 发现没有图片链接，说明是动态加载的图片(用javascript加载的)，那怎么办呢？\nStep 1 先在网页里找找链接长啥样，毕竟用浏览器浏览的话，图片总是会被加载出来的，然后就能看到链接了，果然，在chrome的Elements这个tag里，我们翻到了图片链接：\n不过直接把链接复制到浏览器里打开的话会403，所以我们先搁置一下。\nStep 2 我们要获得某一话的所有图片链接，可以从图上看出似乎有一大段像是加密后的字符串，我们打开第一话和第二话的HTML，用命令行diff一下以后，会发现差异就刚好出现在这串字符串上：我们可以肯定这里面包含了图片链接相关的信息。\nStep 3 既然找到了加密串，那就要找一个钥匙来解码，看一下网页里内容不多，看起来并没有其他有用信息了，但是还有几个.js文件，一个个打开来看一下，终于在其中一个文件里找到了一大堆代码，然后这一大堆里面，有一段看起来又被加密了（有点此地无银三百两啊）： 把这段代码复制到chrome的console里，发现被自动解码了，得到了一个js函数： 我们点开这个函数，看一下里面的内容：\n函数内容 var LZString=(function(){var f=String.fromCharCode;var keyStrBase64=\u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026quot;;var baseReverseDic={};function getBaseValue(alphabet,character){if(!baseReverseDic[alphabet]){baseReverseDic[alphabet]={};for(var i=0;i\u0026lt;alphabet.length;i++){baseReverseDic[alphabet][alphabet.charAt(i)]=i}}return baseReverseDic[alphabet][character]}var LZString={decompressFromBase64:function(input){if(input==null)return\u0026quot;\u0026quot;;if(input==\u0026quot;\u0026quot;)return null;return LZString._0(input.length,32,function(index){return getBaseValue(keyStrBase64,input.charAt(index))})},_0:function(length,resetValue,getNextValue){var dictionary=[],next,enlargeIn=4,dictSize=4,numBits=3,entry=\u0026quot;\u0026quot;,result=[],i,w,bits,resb,maxpower,power,c,data={val:getNextValue(0),position:resetValue,index:1};for(i=0;i\u0026lt;3;i+=1){dictionary[i]=i}bits=0;maxpower=Math.pow(2,2);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}switch(next=bits){case 0:bits=0;maxpower=Math.pow(2,8);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}c=f(bits);break;case 1:bits=0;maxpower=Math.pow(2,16);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}c=f(bits);break;case 2:return\u0026quot;\u0026quot;}dictionary[3]=c;w=c;result.push(c);while(true){if(data.index\u0026gt;length){return\u0026quot;\u0026quot;}bits=0;maxpower=Math.pow(2,numBits);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}switch(c=bits){case 0:bits=0;maxpower=Math.pow(2,8);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}dictionary[dictSize++]=f(bits);c=dictSize-1;enlargeIn--;break;case 1:bits=0;maxpower=Math.pow(2,16);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}dictionary[dictSize++]=f(bits);c=dictSize-1;enlargeIn--;break;case 2:return result.join('')}if(enlargeIn==0){enlargeIn=Math.pow(2,numBits);numBits++}if(dictionary[c]){entry=dictionary[c]}else{if(c===dictSize){entry=w+w.charAt(0)}else{return null}}result.push(entry);dictionary[dictSize++]=w+entry.charAt(0);enlargeIn--;w=entry;if(enlargeIn==0){enlargeIn=Math.pow(2,numBits);numBits++}}}};return LZString})();String.prototype.splic=function(f){return LZString.decompressFromBase64(this).split(f)};   获得这个函数以后，我们尝试着把之前获得的加密串放进去看看： 这看起来就正常多了，而且这里面的 04|05|06|... 之类的信息看起来也能和之前找到的图片链接对应上。但是它似乎并没有按照某个特定的规律来，所以可以肯定还有一个函数来处理这个字符串。\nStep 4 有了这个信息，我们就接着找处理这个字符串的函数，再次观察一下HTML，发现这个Base64的串被包含在了一个\u0026lt;script\u0026gt;当中，长这样：\nscript内容 \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt;window[\u0026quot;\\x65\\x76\\x61\\x6c\u0026quot;](function(p,a,c,k,e,d){e=function(c){return(c\u0026lt;a?\u0026quot;\u0026quot;:e(parseInt(c/a)))+((c=c%a)\u0026gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;}('X.B({\u0026quot;y\u0026quot;:8,\u0026quot;x\u0026quot;:\u0026quot;w v u t s r\u0026quot;,\u0026quot;q\u0026quot;:\u0026quot;8.1\u0026quot;,\u0026quot;p\u0026quot;:o,\u0026quot;n\u0026quot;:\u0026quot;4\u0026quot;,\u0026quot;l\u0026quot;:[\u0026quot;j.1.2\u0026quot;,\u0026quot;A.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;9-a.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;10.1.2\u0026quot;,\u0026quot;11.1.2\u0026quot;,\u0026quot;12.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;14.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;C.1.2\u0026quot;,\u0026quot;P.1.2\u0026quot;,\u0026quot;D.1.2\u0026quot;,\u0026quot;U.1.2\u0026quot;,\u0026quot;W.1.2\u0026quot;,\u0026quot;3.1.2\u0026quot;,\u0026quot;%Y%5%7%6%5%Z%6%7%T.1.2\u0026quot;],\u0026quot;V\u0026quot;:R,\u0026quot;Q\u0026quot;:3,\u0026quot;S\u0026quot;:\u0026quot;/O/z/N/4/\u0026quot;,\u0026quot;M\u0026quot;:0,\u0026quot;L\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;K\u0026quot;:J,\u0026quot;I\u0026quot;:H,\u0026quot;G\u0026quot;:{\u0026quot;e\u0026quot;:F,\u0026quot;m\u0026quot;:\u0026quot;E\u0026quot;}}).i();',62,70,'D4KwDg5sDuCmBGZgCYCsxA03gBgIyD21YADgCFgBRdATlOQHYtLLgsAWZ9LANmducOGZMc/LAGZgYAE6wAkgDsAlgBdmOYDiYAzBQBtYAZwEBjOQEMAtrGCjULUZSzAjCgCbBECo8HMB7H3OAlAAsrJR9vK00dAE9gQG4DQGk5QEYdQHozQD10wA49QHvlQEYndzNLd1cBLGRgBXMIABFTJVMUR2QygE1UcwB9HyMANQBHABVUfU1iHAAvEF6ARU0AYRYp9U4cUWQHOm59HSXOQmQ1KVgANxk3GxZUSm45WAAPJVP3HS6Aa3ajL306pQBXQzGJsMjC9TJpzEolB0dCBkNswPo1PtgHoAppTDp9FYwLUgsBiGQUOJtIp9CE3Mg2ABlACyAAlyNxKAAxASs1lAA==='['\\x73\\x70\\x6c\\x69\\x63']('\\x7c'),0,{})) \u0026lt;/script\u0026gt;   看起来这也是一个函数啊，而且这个Base64的串似乎作为参数了，再次动用chrome的console帮助我们解析一下：\n这下我们大概可以明白几个事情：\n 这段代码实际上是 window[\u0026quot;eval\u0026quot;](...) 省略号部分是一个函数 function(p,a,c,k,e,d), 以 {} 包起来的是函数内容，那return p;} 后面的想必就是这6个参数。  观察一下这6个参数，我们会发现：\n p = 'X.B({\u0026quot;y\u0026quot;:8,\u0026quot;x\u0026quot;:\u0026quot;w v u t s r\u0026quot;,\u0026quot;q\u0026quot;:\u0026quot;8.1\u0026quot;,\u0026quot;p\u0026quot;:o,\u0026quot;n\u0026quot;:\u0026quot;4\u0026quot;,\u0026quot;l\u0026quot;:[\u0026quot;j.1.2\u0026quot;,\u0026quot;A.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;9-a.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;10.1.2\u0026quot;,\u0026quot;11.1.2\u0026quot;,\u0026quot;12.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;14.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;C.1.2\u0026quot;,\u0026quot;P.1.2\u0026quot;,\u0026quot;D.1.2\u0026quot;,\u0026quot;U.1.2\u0026quot;,\u0026quot;W.1.2\u0026quot;,\u0026quot;3.1.2\u0026quot;,\u0026quot;%Y%5%7%6%5%Z%6%7%T.1.2\u0026quot;],\u0026quot;V\u0026quot;:R,\u0026quot;Q\u0026quot;:3,\u0026quot;S\u0026quot;:\u0026quot;/O/z/N/4/\u0026quot;,\u0026quot;M\u0026quot;:0,\u0026quot;L\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;K\u0026quot;:J,\u0026quot;I\u0026quot;:H,\u0026quot;G\u0026quot;:{\u0026quot;e\u0026quot;:F,\u0026quot;m\u0026quot;:\u0026quot;E\u0026quot;}}).i();'\n  a = 62, c = 70\n  k = 'D4KwDg5sDuCmBGZgCYCsxA03gBgIyD21YADgCFgBRdATlOQHYtLLgsAWZ9LANmducOGZMc/LAGZgYAE6wAkgDsAlgBdmOYDiYAzBQBtYAZwEBjOQEMAtrGCjULUZSzAjCgCbBECo8HMB7H3OAlAAsrJR9vK00dAE9gQG4DQGk5QEYdQHozQD10wA49QHvlQEYndzNLd1cBLGRgBXMIABFTJVMUR2QygE1UcwB9HyMANQBHABVUfU1iHAAvEF6ARU0AYRYp9U4cUWQHOm59HSXOQmQ1KVgANxk3GxZUSm45WAAPJVP3HS6Aa3ajL306pQBXQzGJsMjC9TJpzEolB0dCBkNswPo1PtgHoAppTDp9FYwLUgsBiGQUOJtIp9CE3Mg2ABlACyAAlyNxKAAxASs1lAA==='['split']('|')\n  e = 0, d = {}\n 唯一需要处理的似乎就是k了，虽然k里没有|这个符号，不过刚才使用LZString.decompressfromBase64()函数解析出来的东西倒是有很多|。\n自此真相大白了，我们需要做的事情很简单：\n 提取出p,a,c,k,e,d这6个参数。 将k放进LZString.decompressfromBase64()解析一下。 调用 decode_func （也就是 function(p,a,c,k,e,d) ），得到结果。  结果长这样：\n我们要的图片链接就找到啦！在 files 里。\nStep 5: 我们还剩下最后一个问题：有了图片链接但是访问不了（403）怎么办？这似乎是一种简单的反爬虫方式，google一下，只要假装我们是从本站（即这个漫画的网站）进去的，而不是从其他地方进去的，就可以访问了。虽然在浏览器上做不到，但是python里可以通过更改Referer的方式来达到：\ndef get_download_header(): return {'User-Agent': random.choice(USER_AGENTS), \u0026quot;Referer\u0026quot;: \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot;}  Step 6: 最后的最后，就是爬虫的基本过程了，不过我们有一段javascript代码需要运行，怎么在python中运行javascript呢？\n 首先保存一下javascript代码，叫 decode_func.js。内容如下：  const jsdom = require(\u0026quot;jsdom\u0026quot;); const { JSDOM } = jsdom; const dom = new JSDOM(`\u0026lt;!DOCTYPE html\u0026gt;\u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt;`); window = dom.window; document = window.document; XMLHttpRequest = window.XMLHttpRequest; decode_func = window[\u0026quot;eval\u0026quot;](function(p,a,c,k,e,d){e=function(c){return(c\u0026lt;a?\u0026quot;\u0026quot;:e(parseInt(c/a)))+((c=c%a)\u0026gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;})  然后用以下这段代码就可以了：  def load_js(): with open(\u0026quot;decode_func.js\u0026quot;, 'r') as file: js = file.read() context = execjs.compile(js, cwd=\u0026quot;/usr/local/lib/node_modules\u0026quot;) return context context = load_js()  调用的时候就用 res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d)\n最终代码如下：\n参考代码 import requests from bs4 import BeautifulSoup import os import time import random import lzstring import execjs import re import json def create_dir(path): if not os.path.exists(path): os.makedirs(path) root_folder = '/Users/huzhenwei/Desktop/manga/' create_dir(root_folder) USER_AGENTS = [ \u0026quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\u0026quot;, \u0026quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\u0026quot;, \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\u0026quot;, \u0026quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\u0026quot;, ] def get_download_header(): return {'User-Agent': random.choice(USER_AGENTS), \u0026quot;Referer\u0026quot;: \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot;} def load_js(): with open(\u0026quot;decode_func.js\u0026quot;, 'r') as file: js = file.read() context = execjs.compile(js, cwd=\u0026quot;/usr/local/lib/node_modules\u0026quot;) return context context = load_js() def decode(s): x = lzstring.LZString() decoded_str = x.decompressFromBase64(s) return decoded_str.split(\u0026quot;|\u0026quot;) # p = \u0026quot;\u0026quot;\u0026quot;1h.14({\u0026quot;q\u0026quot;:7,\u0026quot;r\u0026quot;:\u0026quot;s t u v w x\u0026quot;,\u0026quot;y\u0026quot;:\u0026quot;7.1\u0026quot;,\u0026quot;A\u0026quot;:B,\u0026quot;C\u0026quot;:\u0026quot;6\u0026quot;,\u0026quot;D\u0026quot;:[\u0026quot;E.1.2\u0026quot;,\u0026quot;F.1.2\u0026quot;,\u0026quot;G.1.2\u0026quot;,\u0026quot;H.1.2\u0026quot;,\u0026quot;o.1.2\u0026quot;,\u0026quot;I.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;a.1.2\u0026quot;,\u0026quot;9.1.2\u0026quot;,\u0026quot;8.1.2\u0026quot;,\u0026quot;l.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;i.1.2\u0026quot;,\u0026quot;j.1.2\u0026quot;,\u0026quot;p.1.2\u0026quot;,\u0026quot;J.1.2\u0026quot;,\u0026quot;Y.1.2\u0026quot;,\u0026quot;L.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;K.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;18.1.2\u0026quot;,\u0026quot;1a.1.2\u0026quot;,\u0026quot;1g.1.2\u0026quot;,\u0026quot;1b.1.2\u0026quot;,\u0026quot;1c.1.2\u0026quot;,\u0026quot;1d.1.2\u0026quot;,\u0026quot;%1e%5%3%4%5%1f%4%3%12.1.2\u0026quot;],\u0026quot;19\u0026quot;:10,\u0026quot;Z\u0026quot;:11,\u0026quot;X\u0026quot;:\u0026quot;/W/z/V/6/\u0026quot;,\u0026quot;U\u0026quot;:0,\u0026quot;T\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;S\u0026quot;:R,\u0026quot;Q\u0026quot;:P,\u0026quot;O\u0026quot;:{\u0026quot;e\u0026quot;:N,\u0026quot;m\u0026quot;:\u0026quot;M\u0026quot;}}).n();\u0026quot;\u0026quot;\u0026quot; # a,c = 62,80 # k=['', 'jpg', 'webp', '9B', 'E5', '8B', '第02回', '27099', 'P0056', 'P0055', 'P0054', 'P0058', 'P0053', 'P0052', '', 'P0059', 'P0060', 'P0051', 'P0061', 'P0062', 'P0050', 'P0057', '', 'preInit', 'P0048', 'P0063', 'bid', 'bname', '总之就是非常可爱', 'fly', 'me', 'to', 'the', 'moon', 'bpic', '', 'cid', '354852', 'cname', 'files', 'P0044', 'P0045', 'P0046', 'P0047', 'P0049', 'P0064', 'P0068', 'P0066', 'GYeIdl7ujUrxJ1ls7JvwpQ', '1612951385', 'sl', '354596', 'prevId', '356912', 'nextId', 'block_cc', 'status', 'zzjsfckafmttm_lj2l', 'ps1', 'path', 'P0065', 'len', 'false', '35', 'BE', 'P0067', 'imgData', 'P0069', 'P0070', 'P0071', 'P0072', 'finished', 'P0073', 'P0075', 'P0076', 'P0077', 'E6', '9F', 'P0074', 'SMH'] # e = 0 # d = dict() # res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d) # print(type(res)) # print(res) # get content of one chapter def get_content(title, url): create_dir(os.path.join(root_folder, title)) res = requests.get(f\u0026quot;https://manhuagui.com{url}\u0026quot;, random.choice(USER_AGENTS)) # print(res.text) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all(lambda tag:tag.name=='script', recursive=True) for item in items: txt = item.string # 必须是item.string, 不能是item.txt if txt and \u0026quot;return p;\u0026quot; in txt: # 如果tag里没有文字，txt==None parts = txt.split(\u0026quot;return p;}(\u0026quot;) part = parts[1][:-2] split_res = re.split(r',([0-9]+,[0-9]+,)', part) p = split_res[0][1:-1] split_res[1] = split_res[1][:-1] a, c = map(int, split_res[1].split(',')) k = split_res[2].split(\u0026quot;'['\u0026quot;)[0][1:] k = decode(k) e = 0 d = dict() res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d) s = re.search('({.+})', res).group(0) # 找到一个由 {} 包裹的group info_dict = json.loads(s) files_list = info_dict[\u0026quot;files\u0026quot;] path_prefix = 'https://i.hamreus.com' + info_dict[\u0026quot;path\u0026quot;] i = 1 for file_name in files_list: complete_path = path_prefix + file_name[:-5] print(complete_path) res = requests.get(complete_path, headers=get_download_header()) img_name = os.path.join(root_folder, title, f'{i}.jpg') with open(img_name, 'wb') as file: file.write(res.content) file.flush() time.sleep(random.uniform(5.0, 10.0)) i += 1 # get manga url list def get_url_list(url): res = requests.get(url, random.choice(USER_AGENTS)) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('div', {\u0026quot;id\u0026quot;: \u0026quot;chapter-list-1\u0026quot;}) for manga_list in items: links = manga_list.find_all(\u0026quot;a\u0026quot;, recursive=True) links = links[1:] for link in links: title = link.get(\u0026quot;title\u0026quot;) ref = link.get(\u0026quot;href\u0026quot;) if title[-1] == '卷': continue print(f\u0026quot;{title}, {ref}\u0026quot;) get_content(title, ref) url = \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot; get_url_list(url)    注：上面这块代码被识别成lua语言了，样式出了点问题，可以在markdown里面指定语言，在第一个 ``` 后面加上语言名即可，如 ```python\n 后记 写这篇blog比玩爬虫本身还累啊，看来我果然不适合写作文（虽然我从小就深刻的明白这个道理）。不过这篇博客很大程度上也是写给自己看的，作为下次爬虫的参考（不知道下次爬虫要等到什么时候了）。\n以后可能会补点儿算法笔记，或者题解之类的。\n","date":"2021-02-01T22:45:03+08:00","permalink":"https://tom0727.github.io/post/002-%E7%88%AC%E8%99%AB/","tags":["爬虫","python"],"title":"初学爬虫小记"},{"categories":["工程"],"contents":"起因 在几天前折腾了爬虫，成功爬下来とにかくかわいい的漫画以后，我发现我折腾似乎上瘾了。聊天时无意提到”要是我有个人网站就好了“，于是就决定动手开始构建咕咕已久的个人网站。\n由于我对自己的前端水平十分有数，所以想都没想就立刻放弃了“要不自己写一个网站？”的想法。\n后来想起之前逛过的ouuan大佬的博客非常好看，我的收藏夹里甚至还有他搭建博客的指南，就直接拿来用了，采用的是 hugo + even主题 + github actions，参考资料如下:\n https://ouuan.gitee.io/post/from-hexo-to-hugo/\n 搭建过程 Step 1 首先阅读ouuan的指南(上述链接)，然后使用他的hugo模版，按照模版里指示的进行clone。\nStep 2 还是按照模版里指示的，修改一下配置文件config.toml里的相关配置，一些需要更改的内容：\n 包含yourname的部分 newContentEditor = \u0026quot;\u0026quot; defaultContentLanguage = \u0026quot;en\u0026quot; [[menu.main]]的相关内容 (视情况进行保留和删除) 不要更改 [params] 中的 version=\u0026quot;4.x\u0026quot;  Step 2.5 因为我打算部署到github pages上，就在github上创建一个新的repository，叫tom0727.github.io\nStep 3 配置完成后，可以 hugo new post/test.md 创建一个新的post(在hugo-blog/content/post/test.md), 按照markdown随便写点东西以后保存，然后 hugo server，打开localhost看一下效果(也可以边写边看效果，热加载真香)。最后用hugo命令生成静态文件，就是hugo-blog/public/文件夹，把这个文件夹内的内容push到github上就可以了。\n注： blog的源代码和网页内容并不是一个东西!\n 源代码: 是hugo-blog/ 下除了hugo-blog/public/以外的内容，包含了 content/, config.toml 之类的文件。 网页内容：只是 hugo-blog/public/内的内容，有了源代码就可以用hugo生成网页内容，但是反之就不可以！  既然两者有别，就要分开管理，我把它们放在同一个repository里，分成2个branch。源代码就放在了master里，网页内容就放在publish上了。\nStep 4 这个时候网页上应该是没有内容的，因为github pages需要设置一下指定deploy的branch，在repository的Settings里，拉到下面看到GitHub Pages，改一下Source branch就可以了：  需要在博文里插入图片的话，假设图片位于 static/images/001/1.png，就写上![image](/images/001/1.png)\n如果是插入link的话，就写 [link_name](https://...) 即可，外部链接记得加https://，不然会被当作本地的某个文件位置。\n 这些步骤做完就可以了，当然这种修改然后发布的方式太麻烦了，切branch也很累，所以就有了Step 5:\nStep 5: 我们配置一下Github actions，它能自动化部署流程。参考资料:\n https://segmentfault.com/a/1190000021815477\n 需要注意，因为源代码和网页内容在同一个repository里，就不用在github上折腾secret key之类的了，直接修改一下 hugo-blog/.github/workflows/deploy.yml (这个是template里自带的) 即可：\n personal_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: publish 将 depth 改成 fetch-depth (不然build的时候会报错)  这样就完成了，从此以后，写一篇新文章的步骤就变成：\n hugo new post/article.md 修改位于content/post/article.md的博客文章 add, commit, 把源代码push到master  这样就可以了，不必切branch然后push网页内容了。\n push到master以后，可以在repository的Actions页面查看一下deploy的情况：  Step 6: 因为github.io似乎被墙了，所以学ouuan弄了一个gitee镜像，教程的话参照这两个就可以了：\n https://jasonkayzk.github.io/2020/09/18/%E5%9C%A8Gitee%E6%90%AD%E5%BB%BAGithub-Pages/\n  https://github.com/yanglbme/gitee-pages-action\n gitee镜像的访问网址：tom0727.gitee.io\n注：在 hugo-blog/.github/workflows/sync.yml里记得设置一下on，不然触发不了自动部署。\n我这里设置的是：\non: push: branches: - master workflow_dispatch:  Step 7: 评论区用很多种，我选用了utterances，部署步骤如下：\n 在Github上安装 utterances app，选择这个博客的repo 在 config.toml 中更改配置，将 [params.utterances] 下的 repo 改成这个repo的名字即可。（可以新开一个repo来储存评论，不过评论会以issues的形式出现在repo里，所以没必要新开一个）  TODO LIST  搞明白baidu push是什么  结语 新的一轮折腾结束了，总体来说还是比较满意这个博客的，个人很喜欢这种极简风的博客，功能也比较全，某种意义上算是告别了在Microsoft Word里做笔记的生活（？），之后打算先补上爬虫的一些笔记，还有搬运一点Word上的笔记吧。\n","date":"2021-02-01T21:21:41+08:00","permalink":"https://tom0727.github.io/post/001-hugo-tutorial/","tags":["hugo","博客"],"title":"Hugo博客搭建小记"},{"categories":null,"contents":"Hello, this is Tom from China! If you have trouble visiting this site (especially for mainland China users), please try visit\nhttps://tom0727.gitee.io/\nAbout me  Year 3 Undergraduate student @ HKU (The University of Hong Kong), 2018-2022 Major in Computer Science Competitive programming as hobby   Resume  Resume (in English): https://github.com/tom0727/Resume/blob/master/Zhenwei%20Hu.pdf Resume (in Chinese): https://github.com/tom0727/Resume/blob/master/%E8%83%A1%E6%8C%AF%E4%B8%BA.pdf  Contact  Email: huzhenweitom@gmail.com QQ/Wechat: 980409152  Links  Codeforces:  Leetcode: tom0727  ","date":"2021-01-31T22:57:58+08:00","permalink":"https://tom0727.github.io/about/","tags":null,"title":"About"},{"categories":null,"contents":"","date":"2020-02-07T17:43:21+08:00","permalink":"https://tom0727.github.io/search/","tags":null,"title":"搜索"}]